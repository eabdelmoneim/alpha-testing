import { useEffect, useMemo } from "react";
import { useQuery, useQueryClient, } from "@tanstack/react-query";
import { watchContractEvents, } from "../../../../event/actions/watch-events.js";
import { getContractEvents } from "../../../../event/actions/get-events.js";
import { getRpcClient } from "../../../../rpc/rpc.js";
import { eth_blockNumber } from "../../../../rpc/actions/eth_blockNumber.js";
/**
 * Watches contract events and returns the logs.
 * @param options - The {@link UseContractEventsOptions | options} for watching contract events.
 * @returns The contract events of the watched contract events.
 * @example
 * ```jsx
 * import { useContractEvents } from "thirdweb/react";
 * const contractEvents = useContractEvents({contract});
 * ```
 * @contract
 */
export function useContractEvents(options) {
    const { contract, events, blockRange = 2000, enabled = true, watch = true, } = options;
    const queryClient = useQueryClient();
    const eventsKey = useMemo(() => events?.reduce((acc, curr) => {
        // we can use the event hash as a unique identifier?
        return acc + `${curr.hash}_`;
    }, "") || "__all__", [events]);
    const queryKey = useMemo(() => [contract.chain.id, contract.address, "logs", eventsKey], [contract.address, contract.chain, eventsKey]);
    const query = useQuery({
        // eslint-disable-next-line @tanstack/query/exhaustive-deps
        queryKey,
        queryFn: async () => {
            const rpcRequest = getRpcClient(contract);
            const currentBlockNumber = await eth_blockNumber(rpcRequest);
            const initialEvents = await getContractEvents({
                contract,
                events: events,
                fromBlock: currentBlockNumber - BigInt(blockRange),
            });
            return initialEvents;
        },
        enabled,
    });
    useEffect(() => {
        if (!enabled || !watch) {
            // don't watch if not enabled or if watch is false
            return;
        }
        // the return is important here because it will unwatch the events
        return watchContractEvents({
            contract,
            onEvents: (newEvents) => {
                queryClient.setQueryData(queryKey, (oldEvents = []) => {
                    const newLogs = [...oldEvents, ...newEvents];
                    return newLogs;
                });
            },
            events,
        });
    }, [contract, enabled, events, blockRange, queryClient, queryKey, watch]);
    return query;
}
//# sourceMappingURL=useContractEvents.js.map