import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useState, useCallback, useRef, useEffect, useContext } from "react";
import { FadeIn } from "../../ui/components/FadeIn.js";
import { OTPInput } from "../../ui/components/OTPInput.js";
import { Spacer } from "../../ui/components/Spacer.js";
import { Spinner } from "../../ui/components/Spinner.js";
import { Container, ModalHeader, Line } from "../../ui/components/basic.js";
import { Button } from "../../ui/components/buttons.js";
import { useCustomTheme } from "../../ui/design-system/CustomThemeProvider.js";
import { StyledButton } from "../../ui/design-system/elements.js";
import { fontSize } from "../../ui/design-system/index.js";
import { Text } from "../../ui/components/text.js";
import { ModalConfigCtx } from "../../providers/wallet-ui-states-provider.js";
import { useWalletConnectionCtx } from "../../../core/hooks/others/useWalletConnectionCtx.js";
import { preAuthenticate } from "../../../../wallets/embedded/core/authentication/index.js";
/**
 * @internal
 */
export function EmbeddedWalletOTPLoginUI(props) {
    const { wallet, done, goBack } = props;
    const email = props.email;
    const { modalSize } = useContext(ModalConfigCtx);
    const isWideModal = modalSize === "wide";
    const locale = props.locale;
    const [otpInput, setOtpInput] = useState("");
    const { client, chain } = useWalletConnectionCtx();
    // const { createInstance, done, chain } = props.connectUIProps.connection;
    // const { goBack } = props.connectUIProps.screenConfig;
    // const [wallet, setWallet] = useState<EmbeddedWallet | null>(null);
    const [verifyStatus, setVerifyStatus] = useState("idle");
    const [emailStatus, setEmailStatus] = useState("sending");
    const [screen] = useState("base");
    const sendEmail = useCallback(async () => {
        setOtpInput("");
        setVerifyStatus("idle");
        setEmailStatus("sending");
        try {
            const status = await preAuthenticate({
                email,
                strategy: "email",
                client,
            });
            setEmailStatus(status);
        }
        catch (e) {
            console.error(e);
            setVerifyStatus("idle");
            setEmailStatus("error");
        }
    }, [client, email]);
    const verify = async (otp) => {
        if (typeof emailStatus !== "object" || otp.length !== 6) {
            return;
        }
        setVerifyStatus("idle");
        if (typeof emailStatus !== "object") {
            return;
        }
        if (!wallet) {
            return;
        }
        try {
            setVerifyStatus("verifying");
            const needsRecoveryCode = emailStatus.recoveryShareManagement === "USER_MANAGED" &&
                (emailStatus.isNewUser || emailStatus.isNewDevice);
            // USER_MANAGED
            if (needsRecoveryCode) {
                if (emailStatus.isNewUser) {
                    try {
                        await wallet.connect({
                            chain,
                            strategy: "email",
                            email,
                            verificationCode: otp,
                            client,
                        });
                    }
                    catch (e) {
                        if (e instanceof Error && e.message.includes("encryption key")) {
                            // TODO: do we need this?
                            // setScreen("create-password");
                        }
                        else {
                            throw e;
                        }
                    }
                }
                else {
                    try {
                        // verifies otp for UI feedback
                        await wallet.connect({
                            chain,
                            strategy: "email",
                            email,
                            verificationCode: otp,
                            client,
                        });
                    }
                    catch (e) {
                        if (e instanceof Error && e.message.includes("encryption key")) {
                            // TODO: do we need this?
                            // setScreen("enter-password-or-recovery-code");
                        }
                        else {
                            throw e;
                        }
                    }
                }
            }
            // AWS_MANAGED
            else {
                const authResult = await wallet.connect({
                    chain,
                    strategy: "email",
                    email,
                    verificationCode: otp,
                    client,
                });
                if (!authResult) {
                    throw new Error("Failed to verify OTP");
                }
                done();
            }
            setVerifyStatus("valid");
        }
        catch (e) {
            if (e?.message?.includes("PAYMENT_METHOD_REQUIRED")) {
                setVerifyStatus("payment_required");
            }
            else {
                setVerifyStatus("invalid");
            }
            console.error("Authentication Error", e);
        }
    };
    // send email on mount
    const emailSentOnMount = useRef(false);
    useEffect(() => {
        if (!emailSentOnMount.current) {
            emailSentOnMount.current = true;
            sendEmail();
        }
    }, [sendEmail]);
    // if (screen === "create-password") {
    //   return (
    //     <CreatePassword
    //       modalSize={size}
    //       email={email}
    //       goBack={goBack}
    //       onPassword={async (password) => {
    //         if (!wallet || typeof emailStatus !== "object") {
    //           return;
    //         }
    //         const authResult = await wallet.connect({
    //          chain,
    //           strategy: "email",
    //           email,
    //           verificationCode: otpInput,
    //           // recoveryCode: password,
    //         });
    //         if (!authResult) {
    //           throw new Error("Failed to verify recovery code");
    //         }
    //         await wallet.connect({
    //           authResult,
    //         });
    //         setConnectedWallet(wallet);
    //         props.connected();
    //       }}
    //     />
    //   );
    // }
    // if (screen === "enter-password-or-recovery-code") {
    //   return (
    //     <EnterPasswordOrRecovery
    //       modalSize={size}
    //       goBack={goBack}
    //       email={email}
    //       onVerify={async (passwordOrRecoveryCode) => {
    //         if (!wallet || typeof emailStatus !== "object") {
    //           return;
    //         }
    //         const authResult = await wallet.authenticate({
    //           strategy: "email_verification",
    //           email,
    //           verificationCode: otpInput,
    //           recoveryCode: passwordOrRecoveryCode,
    //         });
    //         if (!authResult) {
    //           throw new Error("Failed to verify recovery code");
    //         }
    //         await wallet.connect({
    //           authResult,
    //         });
    //         setConnectedWallet(wallet);
    //         props.connected();
    //       }}
    //     />
    //   );
    // }
    if (screen === "base") {
        return (_jsxs(Container, { fullHeight: true, flex: "column", animate: "fadein", children: [_jsx(Container, { p: "lg", children: _jsx(ModalHeader, { title: locale.signIn, onBack: goBack }) }), _jsx(Container, { expand: true, flex: "column", center: "y", children: _jsxs("form", { onSubmit: (e) => {
                            e.preventDefault();
                        }, children: [_jsxs(Container, { flex: "column", center: "x", px: "lg", children: [!isWideModal && _jsx(Spacer, { y: "xl" }), _jsx(Text, { children: locale.emailLoginScreen.enterCodeSendTo }), _jsx(Spacer, { y: "sm" }), _jsx(Text, { color: "primaryText", children: email }), _jsx(Spacer, { y: "xl" })] }), _jsx(OTPInput, { isInvalid: verifyStatus === "invalid", digits: 6, value: otpInput, setValue: (value) => {
                                    setOtpInput(value);
                                    setVerifyStatus("idle"); // reset error
                                    verify(value);
                                }, onEnter: () => {
                                    verify(otpInput);
                                } }), verifyStatus === "invalid" && (_jsxs(FadeIn, { children: [_jsx(Spacer, { y: "md" }), _jsx(Text, { size: "sm", color: "danger", center: true, children: locale.emailLoginScreen.invalidCode })] })), verifyStatus === "payment_required" && (_jsxs(FadeIn, { children: [_jsx(Spacer, { y: "md" }), _jsx(Text, { size: "sm", color: "danger", center: true, children: locale.maxAccountsExceeded })] })), _jsx(Spacer, { y: "xl" }), _jsx(Container, { px: isWideModal ? "xxl" : "lg", children: verifyStatus === "verifying" ? (_jsx(_Fragment, { children: _jsx(Container, { flex: "row", center: "x", animate: "fadein", children: _jsx(Spinner, { size: "lg", color: "accentText" }) }) })) : (_jsx(Container, { animate: "fadein", children: _jsx(Button, { onClick: () => verify(otpInput), variant: "accent", type: "submit", style: {
                                            width: "100%",
                                        }, children: locale.emailLoginScreen.verify }) }, "btn-container")) }), _jsx(Spacer, { y: "xl" }), !isWideModal && _jsx(Line, {}), _jsxs(Container, { p: isWideModal ? undefined : "lg", children: [emailStatus === "error" && (_jsx(_Fragment, { children: _jsx(Text, { size: "sm", center: true, color: "danger", children: locale.emailLoginScreen.failedToSendCode }) })), emailStatus === "sending" && (_jsxs(Container, { flex: "row", center: "both", gap: "xs", style: {
                                            textAlign: "center",
                                        }, children: [_jsx(Text, { size: "sm", children: locale.emailLoginScreen.sendingCode }), _jsx(Spinner, { size: "xs", color: "secondaryText" })] })), typeof emailStatus === "object" && (_jsx(LinkButton, { onClick: sendEmail, type: "button", children: locale.emailLoginScreen.resendCode }))] })] }) })] }));
    }
    return null;
}
const LinkButton = /* @__PURE__ */ StyledButton(() => {
    const theme = useCustomTheme();
    return {
        all: "unset",
        color: theme.colors.accentText,
        fontSize: fontSize.sm,
        cursor: "pointer",
        textAlign: "center",
        fontWeight: 500,
        width: "100%",
        "&:hover": {
            color: theme.colors.primaryText,
        },
    };
});
//# sourceMappingURL=EmbeddedWalletOTPLoginUI.js.map