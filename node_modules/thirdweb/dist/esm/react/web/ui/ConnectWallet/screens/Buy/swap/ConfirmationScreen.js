import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { keyframes } from "@emotion/react";
import { CheckCircledIcon, CheckIcon, CrossCircledIcon, } from "@radix-ui/react-icons";
import { useState } from "react";
import { waitForReceipt } from "../../../../../../../transaction/actions/wait-for-tx-receipt.js";
import { formatNumber } from "../../../../../../../utils/formatNumber.js";
import { useSendTransactionCore } from "../../../../../../core/hooks/contract/useSendTransaction.js";
import { useChainQuery } from "../../../../../../core/hooks/others/useChainQuery.js";
import { useBuyWithCryptoStatus, } from "../../../../../../core/hooks/pay/useBuyWithCryptoStatus.js";
import { shortenString } from "../../../../../../core/utils/addresses.js";
import { Skeleton } from "../../../../components/Skeleton.js";
import { Spacer } from "../../../../components/Spacer.js";
import { Spinner } from "../../../../components/Spinner.js";
import { TokenIcon } from "../../../../components/TokenIcon.js";
import { Container, Line, ModalHeader } from "../../../../components/basic.js";
import { Button } from "../../../../components/buttons.js";
import { Text } from "../../../../components/text.js";
import { useCustomTheme } from "../../../../design-system/CustomThemeProvider.js";
import { StyledDiv } from "../../../../design-system/elements.js";
import { fontSize, iconSize } from "../../../../design-system/index.js";
import { AccentFailIcon } from "../../../icons/AccentFailIcon.js";
import { isNativeToken } from "../../nativeToken.js";
import { SwapFees } from "./Fees.js";
import { formatSeconds } from "./formatSeconds.js";
import { addPendingSwapTransaction } from "./pendingSwapTx.js";
/**
 * @internal
 */
export function SwapConfirmationScreen(props) {
    const sendTransactionMutation = useSendTransactionCore();
    const [swapTx, setSwapTx] = useState();
    const isApprovalRequired = props.buyWithCryptoQuote.approval !== undefined;
    const [step, setStep] = useState(isApprovalRequired ? "approval" : "swap");
    const [status, setStatus] = useState("idle");
    const fromChain = useChainQuery(props.fromChain);
    const toChain = useChainQuery(props.toChain);
    const fromTokenSymbol = isNativeToken(props.fromToken)
        ? fromChain.data?.nativeCurrency?.symbol
        : props.fromToken?.symbol;
    const toTokenSymbol = isNativeToken(props.toToken)
        ? toChain.data?.nativeCurrency?.symbol
        : props.toToken?.symbol;
    if (swapTx) {
        return (_jsx(WaitingForConfirmation, { onBack: () => {
                props.onBack();
            }, onViewPendingTx: props.onViewPendingTx, destinationChain: props.toChain, destinationToken: props.toToken, sourceAmount: `${formatNumber(Number(props.fromAmount), 4)} ${fromTokenSymbol || ""}`, destinationAmount: `${formatNumber(Number(props.toAmount), 4)} ${toTokenSymbol || ""}`, swapTx: swapTx, client: props.client }));
    }
    return (_jsxs(Container, { p: "lg", children: [_jsx(ModalHeader, { title: "Confirm Buy", onBack: props.onBack }), _jsx(Spacer, { y: "lg" }), _jsx(ConfirmItem, { label: "Receive", children: _jsx(TokenInfo, { chain: props.toChain, amount: String(formatNumber(Number(props.toAmount), 4)), symbol: toTokenSymbol || "", token: props.toToken, client: props.client }) }), _jsx(ConfirmItem, { label: "Pay", children: _jsx(TokenInfo, { chain: props.fromChain, amount: String(formatNumber(Number(props.fromAmount), 4)), symbol: fromTokenSymbol || "", token: props.fromToken, client: props.client }) }), _jsx(ConfirmItem, { label: "Fees", children: _jsx(SwapFees, { quote: props.buyWithCryptoQuote, align: "right" }) }), _jsx(ConfirmItem, { label: "Send to", children: _jsx(Text, { color: "primaryText", children: shortenString(props.account.address, false) }) }), _jsx(ConfirmItem, { label: "Time", children: _jsxs(Text, { color: "primaryText", children: ["~", formatSeconds(props.buyWithCryptoQuote.swapDetails.estimated.durationSeconds || 0)] }) }), _jsx(Spacer, { y: "lg" }), isApprovalRequired && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "sm" }), _jsxs(Container, { gap: "sm", flex: "row", style: {
                            justifyContent: "space-between",
                        }, center: "y", color: "accentText", children: [_jsx(Step, { isDone: step === "swap", isActive: step === "approval", label: step === "approval" ? "Approve" : "Approved" }), _jsx(ConnectorLine, {}), _jsx(Step, { isDone: false, label: "Confirm", isActive: step === "swap" })] }), _jsx(Spacer, { y: "lg" })] })), status === "error" && (_jsxs(_Fragment, { children: [_jsxs(Container, { flex: "row", gap: "xs", center: "y", color: "danger", children: [_jsx(CrossCircledIcon, { width: iconSize.sm, height: iconSize.sm }), _jsx(Text, { color: "danger", size: "sm", children: step === "approval" ? "Failed to Approve" : "Failed to Confirm" })] }), _jsx(Spacer, { y: "md" })] })), _jsxs(Button, { variant: "accent", fullWidth: true, disabled: status === "pending", onClick: async () => {
                    if (step === "approval" && props.buyWithCryptoQuote.approval) {
                        try {
                            setStatus("pending");
                            const tx = await sendTransactionMutation.mutateAsync(props.buyWithCryptoQuote.approval);
                            await waitForReceipt({ ...tx, maxBlocksWaitTime: 50 });
                            props.onQuoteFinalized(props.buyWithCryptoQuote);
                            setStep("swap");
                            setStatus("idle");
                        }
                        catch (e) {
                            console.error(e);
                            setStatus("error");
                        }
                    }
                    if (step === "swap") {
                        setStatus("pending");
                        try {
                            const _swapTx = await sendTransactionMutation.mutateAsync(props.buyWithCryptoQuote.transactionRequest);
                            await waitForReceipt({ ..._swapTx, maxBlocksWaitTime: 50 });
                            props.onQuoteFinalized(props.buyWithCryptoQuote);
                            // these will be defined by this time
                            if (fromTokenSymbol && toTokenSymbol && fromChain.data) {
                                addPendingSwapTransaction(props.client, {
                                    source: {
                                        symbol: fromTokenSymbol,
                                        value: props.fromAmount,
                                        chainId: props.fromChain.id,
                                    },
                                    destination: {
                                        symbol: toTokenSymbol,
                                        value: props.toAmount,
                                        chainId: props.toChain.id,
                                    },
                                    status: "PENDING",
                                    transactionHash: _swapTx.transactionHash, // ?? _swapTx.userOpHash,
                                });
                            }
                            setSwapTx({
                                transactionHash: _swapTx.transactionHash, // ?? _swapTx.userOpHash,
                                client: props.client,
                            });
                        }
                        catch (e) {
                            console.error(e);
                            setStatus("error");
                        }
                    }
                }, gap: "xs", children: [step === "approval" ? "Approve" : "Confirm", status === "pending" && _jsx(Spinner, { size: "sm", color: "accentButtonText" })] })] }));
}
const ConnectorLine = /* @__PURE__ */ StyledDiv(() => {
    const theme = useCustomTheme();
    return {
        height: "4px",
        background: theme.colors.borderColor,
        flex: 1,
    };
});
function Step(props) {
    return (_jsxs(Container, { flex: "row", center: "y", gap: "xs", style: {
            fontSize: fontSize.sm,
        }, color: props.isDone
            ? "success"
            : props.isActive
                ? "accentText"
                : "secondaryText", children: [_jsx(Circle, { children: props.isDone ? (_jsx(CheckIcon, { width: iconSize.sm, height: iconSize.sm })) : (_jsx(PulsingDot, { "data-active": props.isActive })) }), props.label] }));
}
const pulseAnimation = keyframes `
0% {
  opacity: 1;
  transform: scale(0.5);
}
100% {
  opacity: 0;
  transform: scale(1.5);
}
`;
const PulsingDot = /* @__PURE__ */ StyledDiv(() => {
    return {
        background: "currentColor",
        width: "9px",
        height: "9px",
        borderRadius: "50%",
        '&[data-active="true"]': {
            animation: `${pulseAnimation} 1s infinite`,
        },
    };
});
const Circle = /* @__PURE__ */ StyledDiv(() => {
    return {
        border: "1px solid currentColor",
        width: "20px",
        height: "20px",
        borderRadius: "50%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
    };
});
function TokenInfo(props) {
    const chainQuery = useChainQuery(props.chain);
    return (_jsxs(Container, { flex: "column", gap: "xxs", style: {
            alignItems: "flex-end",
        }, children: [_jsxs(Container, { flex: "row", center: "y", gap: "xs", children: [_jsxs(Text, { color: "primaryText", size: "md", children: [props.amount, " ", props.symbol] }), _jsx(TokenIcon, { token: props.token, chain: props.chain, size: "sm", client: props.client })] }), chainQuery.data ? (_jsx(Text, { size: "sm", children: chainQuery.data.name })) : (_jsx(Skeleton, { width: "100px", height: fontSize.sm }))] }));
}
function ConfirmItem(props) {
    return (_jsxs(_Fragment, { children: [_jsxs(Container, { flex: "row", gap: "md", py: "md", style: {
                    justifyContent: "space-between",
                }, children: [_jsx(Text, { size: "md", color: "secondaryText", children: props.label }), props.children] }), _jsx(Line, {})] }));
}
function WaitingForConfirmation(props) {
    const swapStatus = useBuyWithCryptoStatus(props.swapTx);
    const isSuccess = swapStatus.data?.status === "COMPLETED";
    const isFailed = swapStatus.data?.status === "FAILED";
    // const isPending = !isSuccess && !isFailed;
    return (_jsx(Container, { animate: "fadein", children: _jsxs(Container, { p: "lg", children: [_jsx(ModalHeader, { title: "Buy", onBack: props.onBack }), _jsx(Spacer, { y: "sm" }), _jsxs(Container, { flex: "column", animate: "fadein", center: "both", color: isSuccess ? "success" : isFailed ? "danger" : "accentText", children: [_jsx(Spacer, { y: "xxl" }), isSuccess ? (_jsx(CheckCircledIcon, { width: iconSize["4xl"], height: iconSize["4xl"] })) : isFailed ? (_jsx(AccentFailIcon, { size: iconSize["4xl"] })) : (_jsxs("div", { style: {
                                position: "relative",
                            }, children: [_jsx(Spinner, { size: "4xl", color: "accentText" }), _jsx("div", { style: {
                                        position: "absolute",
                                        top: "50%",
                                        left: "50%",
                                        transform: "translate(-50%, -50%)",
                                    }, children: _jsx(TokenIcon, { chain: props.destinationChain, token: props.destinationToken, size: "xxl", client: props.client }) })] })), _jsx(Spacer, { y: "xxl" }), _jsx(Text, { color: "primaryText", size: "lg", children: isSuccess
                                ? "Buy Success"
                                : isFailed
                                    ? "Transaction Failed"
                                    : "Buy Pending" }), !isFailed && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "lg" }), _jsxs("div", { children: [_jsxs(Text, { size: "md", inline: true, children: [" ", isSuccess ? "Bought" : "Buy", " "] }), _jsx(Text, { size: "md", color: "primaryText", inline: true, children: props.destinationAmount }), _jsxs(Text, { size: "md", inline: true, children: [" ", "for", " "] }), _jsx(Text, { size: "md", color: "primaryText", inline: true, children: props.sourceAmount })] })] })), isFailed && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "md" }), _jsxs(Text, { size: "sm", children: ["Your transaction ", `couldn't`, " be processed"] })] }))] }), _jsx(Spacer, { y: "xl" }), !isFailed && (_jsx(Button, { variant: "accent", fullWidth: true, onClick: props.onViewPendingTx, children: "View Transactions" })), isFailed && (_jsx(Button, { variant: "accent", fullWidth: true, onClick: props.onBack, children: "Try Again" }))] }) }));
}
//# sourceMappingURL=ConfirmationScreen.js.map