import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { CrossCircledIcon, CheckCircledIcon } from "@radix-ui/react-icons";
import { useState, useMemo } from "react";
import { Skeleton } from "../../components/Skeleton.js";
import { Spacer } from "../../components/Spacer.js";
import { Spinner } from "../../components/Spinner.js";
import { Container, ModalHeader } from "../../components/basic.js";
import { Button } from "../../components/buttons.js";
import { Label, Input } from "../../components/formElements.js";
import { StyledDiv } from "../../design-system/elements.js";
import { iconSize, spacing, fontSize } from "../../design-system/index.js";
import { defaultTokens } from "../defaultTokens.js";
import { useActiveAccount, useActiveWalletChain, } from "../../../../core/hooks/wallets/wallet-hooks.js";
import { useWalletBalance } from "../../../../core/hooks/others/useWalletBalance.js";
import { Text } from "../../components/text.js";
import { useSendToken } from "../../hooks/useSendToken.js";
import { isAddress } from "../../../../../utils/address.js";
import { useWalletConnectionCtx } from "../../../../core/hooks/others/useWalletConnectionCtx.js";
import { TokenSelector, formatTokenBalance } from "./TokenSelector.js";
import { NATIVE_TOKEN } from "./nativeToken.js";
import { TokenIcon } from "../../components/TokenIcon.js";
/**
 * @internal
 */
export function SendFunds(props) {
    const [screen, setScreen] = useState("base");
    const activeChain = useActiveWalletChain();
    const chainId = activeChain?.id;
    let defaultToken = NATIVE_TOKEN;
    if (
    // if we know chainId
    chainId &&
        // if there is a list of tokens for this chain
        props.supportedTokens[chainId] &&
        // if the list of tokens is not the default list
        props.supportedTokens[chainId] !== defaultTokens[chainId]) {
        // use the first token in the list as default selected
        const tokensForChain = props.supportedTokens[chainId];
        const firstToken = tokensForChain && tokensForChain[0];
        if (firstToken) {
            defaultToken = firstToken;
        }
    }
    const [token, setToken] = useState(defaultToken);
    const [receiverAddress, setReceiverAddress] = useState("");
    const [amount, setAmount] = useState("0");
    const chain = useActiveWalletChain();
    const tokenList = (chain?.id ? props.supportedTokens[chain.id] : undefined) || [];
    if (screen === "tokenSelector" && chain) {
        return (_jsx(TokenSelector, { tokenList: tokenList, onBack: () => {
                setScreen("base");
            }, onTokenSelect: (_token) => {
                setToken(_token);
                setScreen("base");
            }, chain: chain }));
    }
    return (_jsx(SendFundsForm, { token: token, onTokenSelect: () => {
            setScreen("tokenSelector");
        }, receiverAddress: receiverAddress, setReceiverAddress: setReceiverAddress, amount: amount, setAmount: setAmount, onBack: props.onBack }));
}
/**
 * @internal
 */
function SendFundsForm(props) {
    const locale = useWalletConnectionCtx().connectLocale.sendFundsScreen;
    const tokenAddress = props.token && "address" in props.token ? props.token.address : undefined;
    const chain = useActiveWalletChain();
    const activeAccount = useActiveAccount();
    const activeChain = useActiveWalletChain();
    const balanceQuery = useWalletBalance({
        chain,
        tokenAddress: tokenAddress,
        address: activeAccount?.address,
    });
    const { receiverAddress, setReceiverAddress, amount, setAmount } = props;
    // Ethereum or Rinkeby or Goerli
    // TODO support ens
    const isENSSupported = false;
    const isValidReceiverAddress = useMemo(() => {
        const isENS = receiverAddress.endsWith(".eth");
        if (!isENSSupported && isENS) {
            return false;
        }
        return isENS || isAddress(receiverAddress);
    }, [receiverAddress, isENSSupported]);
    const showInvalidAddressError = receiverAddress && !isValidReceiverAddress;
    const sendTokenMutation = useSendToken();
    function getErrorMessage(error) {
        const message = error?.data?.message || error?.message;
        if (!message) {
            return locale.transactionFailed;
        }
        if (message.includes("user rejected")) {
            return locale.transactionRejected;
        }
        if (message.includes("insufficient funds")) {
            return locale.insufficientFunds;
        }
        return locale.transactionFailed;
    }
    if (!activeChain) {
        return null; // this should never happen
    }
    if (sendTokenMutation.isError) {
        return (_jsxs(Container, { p: "lg", animate: "fadein", children: [_jsx(ModalHeader, { title: locale.title, onBack: () => {
                        sendTokenMutation.reset();
                    } }), _jsx(Spacer, { y: "xl" }), _jsxs(Container, { flex: "column", gap: "lg", animate: "fadein", center: "both", style: {
                        minHeight: "200px",
                    }, color: "danger", children: [_jsx(CrossCircledIcon, { width: iconSize.xl, height: iconSize.xl }), _jsx(Text, { color: "danger", children: getErrorMessage(sendTokenMutation.error) })] })] }));
    }
    if (sendTokenMutation.isSuccess) {
        return (_jsxs(Container, { p: "lg", animate: "fadein", children: [_jsx(ModalHeader, { title: locale.title, onBack: () => {
                        sendTokenMutation.reset();
                    } }), _jsxs(Container, { flex: "column", gap: "lg", animate: "fadein", center: "both", style: {
                        minHeight: "250px",
                    }, color: "success", children: [_jsx(CheckCircledIcon, { width: iconSize.xl, height: iconSize.xl }), _jsxs(Text, { color: "success", children: [" ", locale.successMessage, " "] })] })] }));
    }
    const tokenName = (props.token && "name" in props.token ? props.token.name : undefined) ||
        balanceQuery?.data?.name;
    const tokenSymbol = (props.token && "symbol" in props.token ? props.token.symbol : undefined) ||
        balanceQuery?.data?.symbol;
    return (_jsxs(Container, { p: "lg", animate: "fadein", children: [_jsx(ModalHeader, { title: locale.title, onBack: props.onBack }), _jsx(Spacer, { y: "xl" }), _jsxs("form", { onSubmit: (e) => {
                    e.preventDefault();
                }, children: [_jsx(Label, { htmlFor: "token", color: "secondaryText", children: locale.token }), _jsx(Spacer, { y: "sm" }), _jsxs(Button, { id: "token", variant: "outline", fullWidth: true, style: {
                            justifyContent: "flex-start",
                            gap: spacing.sm,
                            padding: spacing.sm,
                        }, onClick: props.onTokenSelect, children: [_jsx(TokenIcon, { token: props.token, chain: activeChain, size: "lg" }), _jsxs(Container, { flex: "column", gap: "xs", children: [tokenName ? (_jsx(Text, { size: "sm", color: "primaryText", children: tokenName })) : (_jsx(Skeleton, { height: fontSize.xs, width: "150px" })), balanceQuery.data ? (_jsx(Text, { size: "xs", children: formatTokenBalance(balanceQuery.data) })) : (_jsx(Skeleton, { height: fontSize.xs, width: "100px" }))] })] }), _jsx(Spacer, { y: "lg" }), _jsx(Label, { htmlFor: "receiver", color: "secondaryText", children: locale.sendTo }), _jsx(Spacer, { y: "sm" }), _jsx(Input, { "data-error": showInvalidAddressError, required: true, id: "receiver", placeholder: isENSSupported ? `0x... / ENS name` : "0x...", variant: "outline", value: receiverAddress, onChange: (e) => {
                            setReceiverAddress(e.target.value);
                        } }), showInvalidAddressError && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "xs" }), _jsx(Text, { color: "danger", size: "sm", children: locale.invalidAddress })] })), _jsx(Spacer, { y: "lg" }), _jsx(Label, { htmlFor: "amount", color: "secondaryText", children: locale.amount }), _jsx(Spacer, { y: "sm" }), _jsxs(Container, { relative: true, children: [_jsx(Input, { required: true, type: "number", id: "amount", variant: "outline", value: amount, onChange: (e) => {
                                    setAmount(e.target.value);
                                } }), _jsx(CurrencyBadge, { children: _jsxs(Text, { size: "xs", children: [" ", tokenSymbol, " "] }) })] }), _jsx(Spacer, { y: "xxl" }), _jsxs(Button, { fullWidth: true, variant: "accent", type: "submit", onClick: async () => {
                            if (!receiverAddress || !amount) {
                                return;
                            }
                            await sendTokenMutation.mutateAsync({
                                receiverAddress,
                                amount,
                                tokenAddress: tokenAddress,
                            });
                        }, style: {
                            alignItems: "center",
                            gap: spacing.sm,
                            padding: spacing.md,
                        }, children: [sendTokenMutation.isPending ? locale.sending : locale.submitButton, sendTokenMutation.isPending && (_jsx(Spinner, { size: "sm", color: "accentButtonText" }))] })] })] }));
}
const CurrencyBadge = /* @__PURE__ */ StyledDiv({
    position: "absolute",
    top: "50%",
    transform: "translateY(-50%)",
    right: spacing.sm,
});
//# sourceMappingURL=SendFunds.js.map