import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { ClockIcon, CrossCircledIcon } from "@radix-ui/react-icons";
import { useEffect, useMemo, useState } from "react";
import { polygon } from "../../../../../../chains/chain-definitions/polygon.js";
import { NATIVE_TOKEN_ADDRESS } from "../../../../../../constants/addresses.js";
import { formatNumber } from "../../../../../../utils/formatNumber.js";
import { toEther } from "../../../../../../utils/units.js";
import { getTotalTxCostForBuy } from "../../../../../core/hooks/contract/useSendTransaction.js";
import { useChainQuery, useChainsQuery, } from "../../../../../core/hooks/others/useChainQuery.js";
import { useWalletBalance } from "../../../../../core/hooks/others/useWalletBalance.js";
import { useBuyWithCryptoQuote, } from "../../../../../core/hooks/pay/useBuyWithCryptoQuote.js";
import { useActiveAccount, useActiveWallet, useActiveWalletChain, useSwitchActiveWalletChain, } from "../../../../../core/hooks/wallets/wallet-hooks.js";
import { wait } from "../../../../../core/utils/wait.js";
import { LoadingScreen } from "../../../../wallets/shared/LoadingScreen.js";
import { Drawer, DrawerOverlay, useDrawer, } from "../../../components/Drawer.js";
import { DynamicHeight } from "../../../components/DynamicHeight.js";
import { Skeleton } from "../../../components/Skeleton.js";
import { Spacer } from "../../../components/Spacer.js";
import { Spinner } from "../../../components/Spinner.js";
import { TokenIcon } from "../../../components/TokenIcon.js";
import { Container, Line, ModalHeader } from "../../../components/basic.js";
import { Button } from "../../../components/buttons.js";
import { Text } from "../../../components/text.js";
import { fontSize, iconSize, radius } from "../../../design-system/index.js";
import { useDebouncedValue } from "../../../hooks/useDebouncedValue.js";
import { TokenSelector } from "../TokenSelector.js";
import { NATIVE_TOKEN, isNativeToken, } from "../nativeToken.js";
import { AccountSelectionScreen } from "./AccountSelectionScreen.js";
import { AccountSelectorButton } from "./AccountSelectorButton.js";
import { PaymentSelection } from "./PaymentSelection.js";
import { FeesButton } from "./buttons.js";
import { BuyTokenInput } from "./swap/BuyTokenInput.js";
import { SwapConfirmationScreen } from "./swap/ConfirmationScreen.js";
import { SwapFees } from "./swap/Fees.js";
import { PayWithCrypto } from "./swap/PayWithCrypto.js";
import { formatSeconds } from "./swap/formatSeconds.js";
import { useSwapSupportedChains } from "./swap/useSwapSupportedChains.js";
/**
 * @internal
 */
export function BuyScreen(props) {
    const activeChain = useActiveWalletChain();
    const activeWallet = useActiveWallet();
    const account = useActiveAccount();
    const supportedChainsQuery = useSwapSupportedChains(props.client);
    if (!activeChain || !account || !activeWallet || !supportedChainsQuery.data) {
        return _jsx(LoadingScreen, {});
    }
    return (_jsx(BuyScreenContent, { ...props, activeChain: activeChain, activeWallet: activeWallet, account: account, onViewPendingTx: props.onViewPendingTx, supportedChains: supportedChainsQuery.data, buyForTx: props.buyForTx }));
}
/**
 *
 * @internal
 */
export function BuyScreenContent(props) {
    const { activeChain, account, client, activeWallet, supportedChains, connectLocale, } = props;
    const [isSwitching, setIsSwitching] = useState(false);
    const switchActiveWalletChain = useSwitchActiveWalletChain();
    const [method] = useState("crypto");
    // prefetch chains metadata
    useChainsQuery(supportedChains || [], 50);
    // screens
    const [screen, setScreen] = useState("main");
    const [drawerScreen, setDrawerScreen] = useState();
    const { drawerRef, drawerOverlayRef, onClose } = useDrawer();
    const closeDrawer = () => {
        onClose(() => {
            setDrawerScreen(undefined);
        });
    };
    const initialTokenAmount = props.buyForTx
        ? formatNumber(Number(toEther(props.buyForTx.cost - props.buyForTx.balance)), 4)
        : undefined;
    // token amount
    const [tokenAmount, setTokenAmount] = useState(initialTokenAmount ? String(initialTokenAmount) : "");
    // once the user edits the tokenInput or confirms the Buy - stop updating the token amount
    const [stopUpdatingTokenAmount, setStopUpdatingTokenAmount] = useState(!props.buyForTx);
    const [amountNeeded, setAmountNeeded] = useState(props.buyForTx?.cost);
    // update amount needed every 30 seconds
    // also update the token amount if allowed
    // ( Can't use useQuery because tx can't be added to queryKey )
    useEffect(() => {
        const buyTx = props.buyForTx;
        if (!buyTx || stopUpdatingTokenAmount) {
            return;
        }
        let mounted = true;
        async function pollTxCost() {
            if (!buyTx || !mounted) {
                return;
            }
            try {
                const totalCost = await getTotalTxCostForBuy(buyTx.tx);
                if (!mounted) {
                    return;
                }
                setAmountNeeded(totalCost);
                if (totalCost > buyTx.balance) {
                    const _tokenAmount = String(formatNumber(Number(toEther(totalCost - buyTx.balance)), 4));
                    setTokenAmount(_tokenAmount);
                }
            }
            catch {
                // no op
            }
            await wait(30000);
            pollTxCost();
        }
        pollTxCost();
        return () => {
            mounted = false;
        };
    }, [props.buyForTx, stopUpdatingTokenAmount]);
    const [hasEditedAmount, setHasEditedAmount] = useState(false);
    const isMiniScreen = props.buyForTx ? false : !hasEditedAmount;
    const isChainSupported = useMemo(() => supportedChains?.find((c) => c.id === activeChain.id), [activeChain.id, supportedChains]);
    // selected chain
    const defaultChain = isChainSupported ? activeChain : polygon;
    const [fromChain, setFromChain] = useState(props.buyForTx ? props.buyForTx.tx.chain : defaultChain);
    const [toChain, setToChain] = useState(props.buyForTx ? props.buyForTx.tx.chain : defaultChain);
    const [address, setAddress] = useState(account.address);
    // selected tokens
    const [fromToken, setFromToken] = useState((props.buyForTx ? props.supportedTokens[toChain.id]?.[0] : undefined) ||
        NATIVE_TOKEN);
    const [toToken, setToToken] = useState(props.buyForTx
        ? NATIVE_TOKEN
        : props.supportedTokens[toChain.id]?.[0] || NATIVE_TOKEN);
    const deferredTokenAmount = useDebouncedValue(tokenAmount, 300);
    const fromTokenBalanceQuery = useWalletBalance({
        address: account.address,
        chain: fromChain,
        tokenAddress: isNativeToken(fromToken) ? undefined : fromToken.address,
        client,
    });
    // when a quote is finalized ( approve sent if required or swap sent )
    // we save it here to stop refetching the quote query
    const [finalizedQuote, setFinalizedQuote] = useState();
    const buyWithCryptoParams = deferredTokenAmount &&
        !finalizedQuote &&
        !(fromChain.id === toChain.id && fromToken === toToken)
        ? {
            // wallet
            fromAddress: address,
            // from token
            fromChainId: fromChain.id,
            fromTokenAddress: isNativeToken(fromToken)
                ? NATIVE_TOKEN_ADDRESS
                : fromToken.address,
            toChainId: toChain.id,
            // to
            toTokenAddress: isNativeToken(toToken)
                ? NATIVE_TOKEN_ADDRESS
                : toToken.address,
            toAmount: deferredTokenAmount,
            client,
        }
        : undefined;
    const buyWithCryptoQuoteQuery = useBuyWithCryptoQuote(buyWithCryptoParams, {
        // refetch every 30 seconds
        staleTime: 30 * 1000,
        refetchInterval: 30 * 1000,
        gcTime: 30 * 1000,
    });
    if (screen === "select-from-token") {
        return (_jsx(TokenSelector, { onBack: () => setScreen("main"), tokenList: (fromChain?.id ? props.supportedTokens[fromChain.id] : undefined) ||
                [], onTokenSelect: (tokenInfo) => {
                setFromToken(tokenInfo);
                setScreen("main");
            }, chain: fromChain, chainSelection: {
                chains: supportedChains,
                select: (c) => setFromChain(c),
            }, connectLocale: connectLocale, client: client }));
    }
    if (screen === "select-to-token") {
        return (_jsx(TokenSelector, { onBack: () => setScreen("main"), tokenList: (toChain?.id ? props.supportedTokens[toChain.id] : undefined) || [], onTokenSelect: (tokenInfo) => {
                setToToken(tokenInfo);
                setScreen("main");
            }, chain: toChain, chainSelection: {
                chains: supportedChains,
                select: (c) => setToChain(c),
            }, connectLocale: connectLocale, client: client }));
    }
    const swapQuote = buyWithCryptoQuoteQuery.data;
    const isSwapQuoteError = buyWithCryptoQuoteQuery.isError;
    const getErrorMessage = () => {
        const defaultMessage = "Unable to get price quote";
        try {
            if (buyWithCryptoQuoteQuery.error instanceof Error) {
                if (buyWithCryptoQuoteQuery.error.message.includes("Minimum")) {
                    const msg = buyWithCryptoQuoteQuery.error.message;
                    return msg.replace("Fetch failed: Error: ", "");
                }
            }
            return defaultMessage;
        }
        catch {
            return defaultMessage;
        }
    };
    const sourceTokenAmount = swapQuote?.swapDetails.fromAmount || "";
    const quoteToConfirm = finalizedQuote || buyWithCryptoQuoteQuery.data;
    if (screen === "confirmation" && quoteToConfirm) {
        return (_jsx(SwapConfirmationScreen, { client: client, onBack: () => {
                // remove finalized quote when going back
                setFinalizedQuote(undefined);
                setStopUpdatingTokenAmount(true);
                setScreen("main");
            }, buyWithCryptoQuote: quoteToConfirm, onQuoteFinalized: (_quote) => {
                setFinalizedQuote(_quote);
            }, fromAmount: quoteToConfirm.swapDetails.fromAmount, toAmount: tokenAmount, fromChain: fromChain, toChain: toChain, account: account, fromToken: fromToken, toToken: toToken, onViewPendingTx: props.onViewPendingTx }));
    }
    const isNotEnoughBalance = !!sourceTokenAmount &&
        !!fromTokenBalanceQuery.data &&
        Number(fromTokenBalanceQuery.data.displayValue) < Number(sourceTokenAmount);
    const disableContinue = !swapQuote || isNotEnoughBalance;
    const switchChainRequired = props.activeChain.id !== fromChain.id;
    return (_jsx(Container, { animate: "fadein", children: _jsxs("div", { onClick: (e) => {
                if (drawerScreen &&
                    drawerRef.current &&
                    !drawerRef.current.contains(e.target)) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeDrawer();
                }
            }, children: [drawerScreen && (_jsxs(_Fragment, { children: [_jsx(DrawerOverlay, { ref: drawerOverlayRef }), _jsx(Drawer, { ref: drawerRef, close: closeDrawer, children: _jsxs(DynamicHeight, { children: [drawerScreen === "address" && (_jsx(AccountSelectionScreen, { onSelect: (v) => {
                                            setAddress(v);
                                            closeDrawer();
                                        }, activeAccount: account, activeWallet: props.activeWallet, client: client })), method === "crypto" && (_jsx(_Fragment, { children: drawerScreen === "fees" && (_jsxs("div", { children: [_jsx(Text, { size: "lg", color: "primaryText", children: "Fees" }), _jsx(Spacer, { y: "lg" }), swapQuote && (_jsx(SwapFees, { quote: swapQuote, align: "left" }))] })) }))] }) })] })), _jsxs(Container, { p: "lg", style: {
                        paddingBottom: 0,
                    }, children: [_jsx(ModalHeader, { title: props.buyForTx
                                ? `Not enough ${props.buyForTx.tokenSymbol}`
                                : "Buy", onBack: props.onBack }), _jsx(Spacer, { y: "lg" }), isMiniScreen && _jsx(Spacer, { y: "xl" }), amountNeeded && props.buyForTx ? (_jsx(BuyForTxUI, { amountNeeded: String(formatNumber(Number(toEther(amountNeeded)), 4)), buyForTx: props.buyForTx, client: client })) : null, _jsx(BuyTokenInput, { value: tokenAmount, onChange: async (value) => {
                                setHasEditedAmount(true);
                                setStopUpdatingTokenAmount(true);
                                setTokenAmount(value);
                            }, token: toToken, chain: toChain, onSelectToken: () => setScreen("select-to-token"), client: props.client, hideTokenSelector: !!props.buyForTx })] }), _jsx(Spacer, { y: "md" }), _jsxs(Container, { px: "lg", children: [!isMiniScreen && (_jsxs("div", { children: [_jsx(PaymentSelection, {}), _jsx(Spacer, { y: "md" }), method === "crypto" && (_jsxs(_Fragment, { children: [_jsx(PayWithCrypto, { value: sourceTokenAmount, onSelectToken: () => {
                                                setScreen("select-from-token");
                                            }, chain: fromChain, token: fromToken, isLoading: buyWithCryptoQuoteQuery.isLoading && !sourceTokenAmount, client: client }), _jsx(SecondaryInfo, { quoteIsLoading: buyWithCryptoQuoteQuery.isLoading, estimatedSeconds: buyWithCryptoQuoteQuery.data?.swapDetails.estimated
                                                .durationSeconds, onViewFees: () => setDrawerScreen("fees") })] })), _jsx(Spacer, { y: "md" }), !props.buyForTx && (_jsxs(_Fragment, { children: [_jsxs(Container, { children: [_jsx(Text, { size: "sm", children: "Send To" }), _jsx(Spacer, { y: "xxs" }), _jsx(AccountSelectorButton, { address: address, activeAccount: account, activeWallet: activeWallet, onClick: () => {
                                                        setDrawerScreen("address");
                                                    }, chevron: true, client: client })] }), _jsx(Spacer, { y: "md" })] })), _jsx(Container, { flex: "column", gap: "md", children: method === "crypto" && isSwapQuoteError && (_jsxs("div", { children: [_jsxs(Container, { flex: "row", gap: "xxs", center: "both", color: "danger", children: [_jsx(CrossCircledIcon, { width: iconSize.sm, height: iconSize.sm }), _jsx(Text, { color: "danger", size: "sm", children: getErrorMessage() })] }), _jsx(Spacer, { y: "md" })] })) })] })), method === "crypto" && (_jsxs(_Fragment, { children: [switchChainRequired && (_jsx(Button, { fullWidth: true, variant: "accent", disabled: isMiniScreen, "data-disabled": isMiniScreen, gap: "sm", onClick: async () => {
                                        setIsSwitching(true);
                                        try {
                                            await switchActiveWalletChain(fromChain);
                                        }
                                        catch { }
                                        setIsSwitching(false);
                                    }, children: !isMiniScreen ? (_jsxs(_Fragment, { children: [isSwitching && (_jsx(Spinner, { size: "sm", color: "accentButtonText" })), isSwitching ? "Switching" : "Switch Network"] })) : ("Continue") })), !switchChainRequired && (_jsx(Button, { variant: disableContinue ? "outline" : "accent", fullWidth: true, "data-disabled": disableContinue, disabled: disableContinue, onClick: async () => {
                                        if (!disableContinue) {
                                            setScreen("confirmation");
                                        }
                                    }, gap: "sm", children: isNotEnoughBalance ? "Not Enough Funds" : "Continue" }))] })), method === "creditCard" && (_jsx(Button, { variant: "accent", fullWidth: true, onClick: async () => {
                                setScreen("kado-iframe");
                            }, gap: "sm", children: "Continue" }))] }), _jsx(Spacer, { y: "lg" })] }) }));
}
const ViewFeeIcon = (props) => {
    return (_jsxs("svg", { width: props.size, height: props.size, viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: [_jsx("path", { d: "M9.5 1.5H2.5C1.94772 1.5 1.5 1.94772 1.5 2.5V9.5C1.5 10.0523 1.94772 10.5 2.5 10.5H9.5C10.0523 10.5 10.5 10.0523 10.5 9.5V2.5C10.5 1.94772 10.0523 1.5 9.5 1.5Z", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }), _jsx("path", { d: "M4.5 7.5L7.5 4.5", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" })] }));
};
function SecondaryInfo(props) {
    const { estimatedSeconds, quoteIsLoading } = props;
    return (_jsxs(Container, { bg: "tertiaryBg", flex: "row", borderColor: "borderColor", style: {
            borderRadius: radius.md,
            borderTopLeftRadius: 0,
            borderTopRightRadius: 0,
            justifyContent: "space-between",
            alignItems: "center",
            borderWidth: "1px",
            borderStyle: "solid",
        }, children: [_jsxs(Container, { flex: "row", center: "y", gap: "xxs", color: "accentText", p: "sm", children: [_jsx(ClockIcon, { width: iconSize.sm, height: iconSize.sm }), quoteIsLoading ? (_jsx(Skeleton, { height: fontSize.xs, width: "50px", color: "borderColor" })) : (_jsx(Text, { size: "xs", color: "secondaryText", children: estimatedSeconds !== undefined
                            ? `~${formatSeconds(estimatedSeconds)}`
                            : "--" }))] }), _jsxs(FeesButton, { variant: "secondary", onClick: props.onViewFees, children: [_jsx(Container, { color: "accentText", flex: "row", center: "both", children: _jsx(ViewFeeIcon, { size: iconSize.sm }) }), _jsx(Text, { size: "xs", color: "secondaryText", children: "View Fees" })] })] }));
}
function BuyForTxUI(props) {
    const chainQuery = useChainQuery(props.buyForTx.tx.chain);
    return (_jsxs(Container, { children: [_jsx(Spacer, { y: "xs" }), _jsxs(Container, { flex: "row", style: {
                    justifyContent: "space-between",
                }, children: [_jsx(Text, { size: "sm", children: "Amount Needed" }), _jsxs(Container, { flex: "column", style: {
                            alignItems: "flex-end",
                        }, children: [_jsxs(Container, { flex: "row", gap: "xs", center: "y", children: [_jsxs(Text, { color: "primaryText", size: "sm", children: [props.amountNeeded, " ", props.buyForTx.tokenSymbol] }), _jsx(TokenIcon, { chain: props.buyForTx.tx.chain, client: props.client, size: "sm", token: NATIVE_TOKEN })] }), _jsx(Spacer, { y: "xxs" }), chainQuery.data ? (_jsxs(Text, { size: "sm", children: [" ", chainQuery.data.name] })) : (_jsx(Skeleton, { height: fontSize.sm, width: "50px" }))] })] }), _jsx(Spacer, { y: "md" }), _jsx(Line, {}), _jsx(Spacer, { y: "md" }), _jsxs(Container, { flex: "row", style: {
                    justifyContent: "space-between",
                }, children: [_jsx(Text, { size: "sm", children: "Your Balance" }), _jsxs(Container, { flex: "row", gap: "xs", children: [_jsxs(Text, { color: "primaryText", size: "sm", children: [formatNumber(Number(toEther(props.buyForTx.balance)), 4), " ", props.buyForTx.tokenSymbol] }), _jsx(TokenIcon, { chain: props.buyForTx.tx.chain, client: props.client, size: "sm", token: NATIVE_TOKEN })] })] }), _jsx(Spacer, { y: "md" }), _jsx(Line, {}), _jsx(Spacer, { y: "lg" }), _jsx(Text, { center: true, size: "sm", children: "Purchase" }), _jsx(Spacer, { y: "xxs" })] }));
}
//# sourceMappingURL=SwapScreen.js.map