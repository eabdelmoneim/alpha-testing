"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedWallet = void 0;
const embedded_wallets_js_1 = require("../../interfaces/embedded-wallets/embedded-wallets.js");
const LocalStorage_js_1 = require("../../utils/Storage/LocalStorage.js");
const rpc_js_1 = require("../../../../../rpc/rpc.js");
const utils_js_1 = require("../../../../../chains/utils.js");
const eth_sendRawTransaction_js_1 = require("../../../../../rpc/actions/eth_sendRawTransaction.js");
/**
 *
 */
class EmbeddedWallet {
    /**
     * Not meant to be initialized directly. Call {@link initializeUser} to get an instance
     * @internal
     */
    constructor({ client, querier }) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "walletManagerQuerier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "localStorage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.walletManagerQuerier = querier;
        this.localStorage = new LocalStorage_js_1.LocalStorage({ clientId: client.clientId });
    }
    /**
     * Used to set-up the user device in the case that they are using incognito
     * @returns `{walletAddress : string }` The user's wallet details
     * @internal
     */
    async postWalletSetUp({ deviceShareStored, walletAddress, isIframeStorageEnabled, walletUserId, }) {
        if (!isIframeStorageEnabled) {
            await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);
        }
        return { walletAddress };
    }
    /**
     * Gets the various status states of the user
     * @example
     * ```typescript
     *  const userStatus = await Paper.getUserWalletStatus();
     *  switch (userStatus.status) {
     *  case UserWalletStatus.LOGGED_OUT: {
     *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user
     *    break;
     *  }
     *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {
     *    // User is logged in, but does not have a wallet associated with it
     *    // you also have access to the user's details
     *    userStatus.user.authDetails;
     *    break;
     *  }
     *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {
     *    // User is logged in and created a wallet already, but is missing the device shard
     *    // You have access to:
     *    userStatus.user.authDetails;
     *    userStatus.user.walletAddress;
     *    break;
     *  }
     *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {
     *    // user is logged in and wallet is all set up.
     *    // You have access to:
     *    userStatus.user.authDetails;
     *    userStatus.user.walletAddress;
     *    userStatus.user.wallet;
     *    break;
     *  }
     *}
     *```
     * @returns `{GetUserWalletStatusFnReturnType}` an object to containing various information on the user statuses
     * @internal
     */
    async getUserWalletStatus() {
        const userStatus = await this.walletManagerQuerier.call({
            procedureName: "getUserStatus",
            params: undefined,
        });
        if (userStatus.status === embedded_wallets_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {
            return {
                status: embedded_wallets_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
                ...userStatus.user,
                wallet: this,
            };
        }
        else if (userStatus.status === embedded_wallets_js_1.UserWalletStatus.LOGGED_IN_NEW_DEVICE) {
            return {
                status: embedded_wallets_js_1.UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,
                ...userStatus.user,
            };
        }
        else if (userStatus.status === embedded_wallets_js_1.UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED) {
            return {
                status: embedded_wallets_js_1.UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,
                ...userStatus.user,
            };
        }
        else {
            // Logged out
            return { status: userStatus.status };
        }
    }
    /**
     * Returns an account that communicates with the iFrame for signing operations
     * @internal
     */
    async getAccount() {
        const querier = this
            .walletManagerQuerier;
        const { address } = await querier.call({
            procedureName: "getAddress",
            params: undefined,
        });
        const signTransaction = async (tx) => {
            const { signedTransaction } = await querier.call({
                procedureName: "signTransaction",
                params: {
                    transaction: {
                        to: tx.to ?? undefined,
                        data: tx.data,
                        value: tx.value,
                        gasLimit: tx.gas,
                        gasPrice: tx.gasPrice,
                        nonce: tx.nonce,
                        chainId: tx.chainId,
                        accessList: tx.accessList,
                        maxFeePerGas: tx.maxFeePerGas,
                        maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
                        type: tx.maxFeePerGas ? 2 : 0,
                    },
                    chainId: tx.chainId,
                    rpcEndpoint: `https://${tx.chainId}.rpc.thirdweb.com`, // TODO (ew) shouldnt be needed
                },
            });
            return signedTransaction;
        };
        const client = this.client;
        return {
            address,
            async sendTransaction(tx) {
                const rpcRequest = (0, rpc_js_1.getRpcClient)({
                    client,
                    chain: (0, utils_js_1.defineChain)(tx.chainId),
                });
                const signedTx = await signTransaction(tx);
                const transactionHash = await (0, eth_sendRawTransaction_js_1.eth_sendRawTransaction)(rpcRequest, signedTx);
                return {
                    transactionHash,
                };
            },
            async signMessage({ message }) {
                const messageDecoded = typeof message === "string" ? message : message.raw;
                const { signedMessage } = await querier.call({
                    procedureName: "signMessage",
                    params: {
                        message: messageDecoded, // wants Bytes or string
                        chainId: 1, // TODO check if we need this
                    },
                });
                return signedMessage;
            },
            async signTypedData(_typedData) {
                // deleting EIP712 Domain as it results in ambiguous primary type on some cases
                // this happens when going from viem to ethers via the iframe
                if (_typedData.types && _typedData.types.EIP712Domain) {
                    delete _typedData.types.EIP712Domain;
                }
                const chainId = Number(_typedData.domain?.chainId || 1);
                const { signedTypedData } = await querier.call({
                    procedureName: "signTypedDataV4",
                    params: {
                        domain: _typedData.domain,
                        types: _typedData.types,
                        message: _typedData.message,
                        chainId,
                        rpcEndpoint: `https://${chainId}.rpc.thirdweb.com`, // TODO (ew) shouldnt be needed
                    },
                });
                return signedTypedData;
            },
        };
    }
}
exports.EmbeddedWallet = EmbeddedWallet;
//# sourceMappingURL=embedded-wallet.js.map