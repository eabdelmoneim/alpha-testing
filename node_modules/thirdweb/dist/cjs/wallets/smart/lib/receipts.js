"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserOpEventFromEntrypoint = void 0;
const viem_1 = require("viem");
const contract_js_1 = require("../../../contract/contract.js");
const constants_js_1 = require("./constants.js");
const prepare_event_js_1 = require("../../../event/prepare-event.js");
const get_events_js_1 = require("../../../event/actions/get-events.js");
/**
 * @internal
 */
async function getUserOpEventFromEntrypoint(args) {
    const { blockNumber, blockRange, chain, userOpHash, client } = args;
    const fromBlock = blockNumber > blockRange ? blockNumber - blockRange : blockNumber;
    const entryPointContract = (0, contract_js_1.getContract)({
        address: constants_js_1.ENTRYPOINT_ADDRESS,
        chain: chain,
        client: client,
    });
    const userOpEvent = (0, prepare_event_js_1.prepareEvent)({
        signature: "event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed)",
        // actually only want *this* userOpHash, so we can filter here
        filters: {
            userOpHash: userOpHash,
        },
    });
    const events = await (0, get_events_js_1.getContractEvents)({
        contract: entryPointContract,
        events: [userOpEvent],
        fromBlock,
    });
    // no longe need to `find` here because we already filter in the getContractEvents() call above
    const event = events[0];
    // UserOp can revert, so we need to surface revert reason
    if (event && event.args.success === false) {
        const revertOpEvent = (0, prepare_event_js_1.prepareEvent)({
            signature: "event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)",
            filters: {
                userOpHash: userOpHash,
            },
        });
        const revertEvent = await (0, get_events_js_1.getContractEvents)({
            contract: entryPointContract,
            events: [revertOpEvent],
            blockHash: event.blockHash,
        });
        const firstRevertEvent = revertEvent[0];
        if (firstRevertEvent) {
            const message = (0, viem_1.decodeErrorResult)({
                data: firstRevertEvent.args.revertReason,
            });
            throw new Error(`UserOp failed with reason: '${message.args.join(",")}' at txHash: ${event.transactionHash}`);
        }
        else {
            throw new Error("UserOp failed with unknown reason with txHash: " +
                event.transactionHash);
        }
    }
    return event;
}
exports.getUserOpEventFromEntrypoint = getUserOpEventFromEntrypoint;
//# sourceMappingURL=receipts.js.map