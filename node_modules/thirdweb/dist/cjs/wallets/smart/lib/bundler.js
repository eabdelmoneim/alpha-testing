"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserOpReceipt = exports.estimateUserOpGas = exports.bundleUserOp = void 0;
const fetch_js_1 = require("../../../utils/fetch.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
const constants_js_1 = require("./constants.js");
const utils_js_1 = require("./utils.js");
/**
 * @internal
 */
async function bundleUserOp(args) {
    return sendBundlerRequest({
        ...args,
        operation: "eth_sendUserOperation",
        params: [
            (0, utils_js_1.hexlifyUserOp)(args.userOp),
            args.options.overrides?.entrypointAddress ?? constants_js_1.ENTRYPOINT_ADDRESS,
        ],
    });
}
exports.bundleUserOp = bundleUserOp;
/**
 * @internal
 */
async function estimateUserOpGas(args) {
    const res = await sendBundlerRequest({
        ...args,
        operation: "eth_estimateUserOperationGas",
        params: [
            (0, utils_js_1.hexlifyUserOp)(args.userOp),
            args.options.overrides?.entrypointAddress ?? constants_js_1.ENTRYPOINT_ADDRESS,
        ],
    });
    return {
        preVerificationGas: (0, hex_js_1.hexToBigInt)(res.preVerificationGas),
        verificationGas: (0, hex_js_1.hexToBigInt)(res.verificationGas),
        verificationGasLimit: (0, hex_js_1.hexToBigInt)(res.verificationGasLimit),
        callGasLimit: (0, hex_js_1.hexToBigInt)(res.callGasLimit),
    };
}
exports.estimateUserOpGas = estimateUserOpGas;
/**
 * @internal
 */
async function getUserOpReceipt(args) {
    const res = await sendBundlerRequest({
        ...args,
        operation: "eth_getUserOperationReceipt",
        params: [args.userOpHash],
    });
    // TODO theres more info in res we could be returning here
    return res?.receipt;
}
exports.getUserOpReceipt = getUserOpReceipt;
async function sendBundlerRequest(args) {
    const { options, operation, params } = args;
    if (constants_js_1.DEBUG) {
        console.debug(`sending ${operation} with payload:`, params);
    }
    const bundlerUrl = options.overrides?.bundlerUrl ?? (0, constants_js_1.getDefaultBundlerUrl)(options.chain);
    const fetchWithHeaders = (0, fetch_js_1.getClientFetch)(options.client);
    const response = await fetchWithHeaders(bundlerUrl, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            jsonrpc: "2.0",
            id: 1,
            method: operation,
            params,
        }),
    });
    const res = await response.json();
    if (!response.ok || res.error) {
        let error = res.error || response.statusText;
        if (typeof error === "object") {
            error = JSON.stringify(error);
        }
        const code = res.code || "UNKNOWN";
        throw new Error(`${operation} error: ${error}
Status: ${response.status}
Code: ${code}`);
    }
    if (constants_js_1.DEBUG) {
        console.debug(`${operation} result:`, res);
    }
    return res.result;
}
//# sourceMappingURL=bundler.js.map