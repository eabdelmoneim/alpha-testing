"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.autoConnectWC = exports.connectWC = void 0;
const viem_1 = require("viem");
const normalizeChainId_js_1 = require("../utils/normalizeChainId.js");
const chains_js_1 = require("../utils/chains.js");
const json_js_1 = require("../../utils/json.js");
const utils_js_1 = require("../../chains/utils.js");
const ethereum_js_1 = require("../../chains/chain-definitions/ethereum.js");
const hex_js_1 = require("../../utils/encoding/hex.js");
const defaultDappMetadata_js_1 = require("../utils/defaultDappMetadata.js");
const defaultWCProjectId = "08c4b07e3ad25f1a27c14a4e8cecb6f0";
const NAMESPACE = "eip155";
const ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
// const isNewChainsStale = true;
const defaultShowQrModal = true;
/**
 * @internal
 */
async function connectWC(options, emitter) {
    const provider = await initProvider(options);
    const wcOptions = options.walletConnect;
    const targetChain = options?.chain || ethereum_js_1.ethereum;
    const targetChainId = targetChain.id;
    const rpc = (0, utils_js_1.getRpcUrlForChain)({
        chain: targetChain,
        client: options.client,
    });
    const { onDisplayUri, onSessionRequestSent } = wcOptions || {};
    if (onDisplayUri || onSessionRequestSent) {
        if (onDisplayUri) {
            provider.events.addListener("display_uri", onDisplayUri);
        }
        if (onSessionRequestSent) {
            provider.signer.client.on("session_request_sent", onSessionRequestSent);
            provider.events.addListener("disconnect", () => {
                provider.signer.client.off("session_request_sent", onSessionRequestSent);
            });
        }
    }
    // If there no active session, or the chain is stale, force connect.
    if (!provider.session) {
        await provider.connect({
            pairingTopic: wcOptions?.pairingTopic,
            chains: [Number(targetChainId)],
            rpcMap: {
                [targetChainId.toString()]: rpc,
            },
        });
    }
    // If session exists and chains are authorized, enable provider for required chain
    const addresses = await provider.enable();
    const address = addresses[0];
    if (!address) {
        throw new Error("No accounts found on provider.");
    }
    const chain = (0, utils_js_1.defineChain)((0, normalizeChainId_js_1.normalizeChainId)(provider.chainId));
    if (wcOptions?.onDisplayUri) {
        provider.events.removeListener("display_uri", wcOptions.onDisplayUri);
    }
    return onConnect(address, chain, provider, emitter);
}
exports.connectWC = connectWC;
/**
 * Auto connect to already connected wallet connect session.
 * @internal
 */
async function autoConnectWC(options, emitter) {
    const provider = await initProvider(options.savedConnectParams
        ? {
            chain: options.savedConnectParams.chain,
            client: options.client,
            walletConnect: {
                pairingTopic: options.savedConnectParams.pairingTopic,
                optionalChains: options.savedConnectParams.optionalChains,
            },
        }
        : {
            client: options.client,
            walletConnect: {},
        });
    const address = provider.accounts[0];
    if (!address) {
        throw new Error("No accounts found on provider.");
    }
    const chain = (0, utils_js_1.defineChain)((0, normalizeChainId_js_1.normalizeChainId)(provider.chainId));
    return onConnect(address, chain, provider, emitter);
}
exports.autoConnectWC = autoConnectWC;
// /**
//  * @internal
//  */
// export async function disconnectWC(wallet: Wallet<WCSupportedWalletIds>) {
//   const provider = walletToProviderMap.get(wallet);
//   // const storage = getWalletData(wallet)?.storage;
//   onDisconnect(wallet);
//   // if (storage) {
//   //   deleteConnectParamsFromStorage(storage, wallet.id);
//   // }
//   if (provider) {
//     provider.disconnect();
//   }
// }
// Connection utils -----------------------------------------------------------------------------------------------
async function initProvider(options) {
    const wcOptions = options.walletConnect;
    const { EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await Promise.resolve().then(() => require("@walletconnect/ethereum-provider"));
    const targetChain = options.chain || ethereum_js_1.ethereum;
    const rpc = (0, utils_js_1.getRpcUrlForChain)({
        chain: targetChain,
        client: options.client,
    });
    const provider = await EthereumProvider.init({
        showQrModal: wcOptions?.showQrModal === undefined
            ? defaultShowQrModal
            : wcOptions.showQrModal,
        projectId: wcOptions?.projectId || defaultWCProjectId,
        optionalMethods: OPTIONAL_METHODS,
        optionalEvents: OPTIONAL_EVENTS,
        optionalChains: [targetChain.id],
        metadata: {
            name: wcOptions?.appMetadata?.name || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().name,
            description: wcOptions?.appMetadata?.description ||
                (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().description,
            url: wcOptions?.appMetadata?.url || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().url,
            icons: [
                wcOptions?.appMetadata?.logoUrl || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().logoUrl,
            ],
        },
        rpcMap: {
            [targetChain.id]: rpc,
        },
        qrModalOptions: wcOptions?.qrModalOptions,
        disableProviderPing: true,
    });
    provider.events.setMaxListeners(Infinity);
    return provider;
}
function onConnect(address, chain, provider, emitter) {
    const account = {
        address,
        async sendTransaction(tx) {
            const transactionHash = (await provider.request({
                method: "eth_sendTransaction",
                params: [
                    {
                        gas: tx.gas ? (0, hex_js_1.numberToHex)(tx.gas) : undefined,
                        value: tx.value ? (0, hex_js_1.numberToHex)(tx.value) : undefined,
                        from: this.address,
                        to: tx.to,
                        data: tx.data,
                    },
                ],
            }));
            return {
                transactionHash,
            };
        },
        async signMessage({ message }) {
            return provider.request({
                method: "personal_sign",
                params: [message, this.address],
            });
        },
        async signTypedData(data) {
            const { domain, message, primaryType } = data;
            const types = {
                EIP712Domain: (0, viem_1.getTypesForEIP712Domain)({ domain }),
                ...data.types,
            };
            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
            // as we can't statically check this with TypeScript.
            (0, viem_1.validateTypedData)({ domain, message, primaryType, types });
            const typedData = (0, json_js_1.stringify)({ domain: domain ?? {}, message, primaryType, types }, (_, value) => ((0, hex_js_1.isHex)(value) ? value.toLowerCase() : value));
            return await provider.request({
                method: "eth_signTypedData_v4",
                params: [this.address, typedData],
            });
        },
    };
    function disconnect() {
        if (!provider) {
            return;
        }
        provider.disconnect();
        provider.removeListener("accountsChanged", onAccountsChanged);
        provider.removeListener("chainChanged", onChainChanged);
        provider.removeListener("disconnect", onDisconnect);
    }
    function onDisconnect() {
        disconnect();
        emitter.emit("disconnect", undefined);
    }
    function onAccountsChanged(accounts) {
        if (accounts.length === 0) {
            onDisconnect();
        }
        else {
            emitter.emit("accountsChanged", accounts);
        }
    }
    function onChainChanged(newChainId) {
        const newChain = (0, utils_js_1.defineChain)((0, normalizeChainId_js_1.normalizeChainId)(newChainId));
        emitter.emit("chainChanged", newChain);
    }
    provider.on("accountsChanged", onAccountsChanged);
    provider.on("chainChanged", onChainChanged);
    provider.on("disconnect", onDisconnect);
    return [
        account,
        chain,
        disconnect,
        (newChain) => switchChainWC(provider, newChain),
    ];
}
// Storage utils  -----------------------------------------------------------------------------------------------
function getNamespaceMethods(provider) {
    return provider.session?.namespaces[NAMESPACE]?.methods || [];
}
function getNamespaceChainsIds(provider) {
    if (!provider) {
        return [];
    }
    const chainIds = provider.session?.namespaces[NAMESPACE]?.chains?.map((chain) => parseInt(chain.split(":")[1] || ""));
    return chainIds ?? [];
}
async function switchChainWC(provider, chain) {
    const chainId = chain.id;
    try {
        const namespaceChains = getNamespaceChainsIds(provider);
        const namespaceMethods = getNamespaceMethods(provider);
        const isChainApproved = namespaceChains.includes(chainId);
        if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
            const apiChain = await (0, utils_js_1.getChainMetadata)(chain);
            const firstExplorer = apiChain.explorers && apiChain.explorers[0];
            const blockExplorerUrls = firstExplorer
                ? { blockExplorerUrls: [firstExplorer.url] }
                : {};
            await provider.request({
                method: ADD_ETH_CHAIN_METHOD,
                params: [
                    {
                        chainId: (0, hex_js_1.numberToHex)(apiChain.chainId),
                        chainName: apiChain.name,
                        nativeCurrency: apiChain.nativeCurrency,
                        rpcUrls: (0, chains_js_1.getValidPublicRPCUrl)(apiChain), // no clientId on purpose
                        ...blockExplorerUrls,
                    },
                ],
            });
            // const requestedChains = await getRequestedChainsIds(wallet);
            // requestedChains.push(chainId);
            // setRequestedChainsIds(wallet, requestedChains);
        }
        await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: (0, hex_js_1.numberToHex)(chainId) }],
        });
    }
    catch (error) {
        const message = typeof error === "string" ? error : error?.message;
        if (/user rejected request/i.test(message)) {
            throw new viem_1.UserRejectedRequestError(error);
        }
        throw new viem_1.SwitchChainError(error);
    }
}
//# sourceMappingURL=index.js.map