"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useContractEvents = void 0;
const react_1 = require("react");
const react_query_1 = require("@tanstack/react-query");
const watch_events_js_1 = require("../../../../event/actions/watch-events.js");
const get_events_js_1 = require("../../../../event/actions/get-events.js");
const rpc_js_1 = require("../../../../rpc/rpc.js");
const eth_blockNumber_js_1 = require("../../../../rpc/actions/eth_blockNumber.js");
/**
 * Watches contract events and returns the logs.
 * @param options - The {@link UseContractEventsOptions | options} for watching contract events.
 * @returns The contract events of the watched contract events.
 * @example
 * ```jsx
 * import { useContractEvents } from "thirdweb/react";
 * const contractEvents = useContractEvents({contract});
 * ```
 * @contract
 */
function useContractEvents(options) {
    const { contract, events, blockRange = 2000, enabled = true, watch = true, } = options;
    const queryClient = (0, react_query_1.useQueryClient)();
    const eventsKey = (0, react_1.useMemo)(() => events?.reduce((acc, curr) => {
        // we can use the event hash as a unique identifier?
        return acc + `${curr.hash}_`;
    }, "") || "__all__", [events]);
    const queryKey = (0, react_1.useMemo)(() => [contract.chain.id, contract.address, "logs", eventsKey], [contract.address, contract.chain, eventsKey]);
    const query = (0, react_query_1.useQuery)({
        // eslint-disable-next-line @tanstack/query/exhaustive-deps
        queryKey,
        queryFn: async () => {
            const rpcRequest = (0, rpc_js_1.getRpcClient)(contract);
            const currentBlockNumber = await (0, eth_blockNumber_js_1.eth_blockNumber)(rpcRequest);
            const initialEvents = await (0, get_events_js_1.getContractEvents)({
                contract,
                events: events,
                fromBlock: currentBlockNumber - BigInt(blockRange),
            });
            return initialEvents;
        },
        enabled,
    });
    (0, react_1.useEffect)(() => {
        if (!enabled || !watch) {
            // don't watch if not enabled or if watch is false
            return;
        }
        // the return is important here because it will unwatch the events
        return (0, watch_events_js_1.watchContractEvents)({
            contract,
            onEvents: (newEvents) => {
                queryClient.setQueryData(queryKey, (oldEvents = []) => {
                    const newLogs = [...oldEvents, ...newEvents];
                    return newLogs;
                });
            },
            events,
        });
    }, [contract, enabled, events, blockRange, queryClient, queryKey, watch]);
    return query;
}
exports.useContractEvents = useContractEvents;
//# sourceMappingURL=useContractEvents.js.map