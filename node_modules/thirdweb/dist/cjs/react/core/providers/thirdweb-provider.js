"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThirdwebProvider = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const wait_for_tx_receipt_js_1 = require("../../../transaction/actions/wait-for-tx-receipt.js");
const types_js_1 = require("../../../transaction/types.js");
const type_guards_js_1 = require("../../../utils/type-guards.js");
const RootElementContext_js_1 = require("./RootElementContext.js");
/**
 * The ThirdwebProvider is component is a provider component that sets up the React Query client.
 * @param props - The props for the ThirdwebProvider
 * @example
 * ```jsx
 * import { ThirdwebProvider } from "thirdweb/react";
 *
 * function Example() {
 *  return (
 *    <ThirdwebProvider>
 *      <App />
 *    </ThirdwebProvider>
 *   )
 * }
 * ```
 * @component
 */
function ThirdwebProvider(props) {
    const [el, setEl] = (0, react_1.useState)(null);
    const [queryClient] = (0, react_1.useState)(() => new react_query_1.QueryClient({
        defaultOptions: {
            mutations: {
                onSettled: (data, error, variables) => {
                    if (error) {
                        // TODO: remove - but useful for debug now
                        console.error("[Mutation Error]", error);
                    }
                    if ((0, types_js_1.isBaseTransactionOptions)(variables)) {
                        if ((0, type_guards_js_1.isObjectWithKeys)(data, ["transactionHash", "client", "chain"])) {
                            (0, wait_for_tx_receipt_js_1.waitForReceipt)(data)
                                .catch((e) => {
                                // swallow errors for receipts, but log
                                console.error("[Transaction Error]", e);
                            })
                                .then(() => {
                                return Promise.all([
                                    queryClient.invalidateQueries({
                                        queryKey: 
                                        // invalidate any readContract queries for this chainId:contractAddress
                                        [
                                            "readContract",
                                            variables.__contract?.chain.id,
                                            variables.__contract?.address,
                                        ],
                                    }),
                                    queryClient.invalidateQueries({
                                        // invalidate any walletBalance queries for this chainId
                                        // TODO: add wallet address in here if we can get it somehow
                                        queryKey: [
                                            "walletBalance",
                                            variables.__contract?.chain.id,
                                        ],
                                    }),
                                ]);
                            });
                        }
                    }
                },
            },
            queries: {
                // With SSR, we usually want to set some default staleTime
                // above 0 to avoid refetching immediately on the client
                staleTime: 60 * 1000,
            },
        },
    }));
    return ((0, jsx_runtime_1.jsxs)(react_query_1.QueryClientProvider, { client: queryClient, children: [(0, jsx_runtime_1.jsx)(RootElementContext_js_1.SetRootElementContext.Provider, { value: setEl, children: props.children }), el] }));
}
exports.ThirdwebProvider = ThirdwebProvider;
//# sourceMappingURL=thirdweb-provider.js.map