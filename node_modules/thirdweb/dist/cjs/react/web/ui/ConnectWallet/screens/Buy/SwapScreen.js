"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapScreenContent = exports.SwapScreen = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_icons_1 = require("@radix-ui/react-icons");
const react_1 = require("react");
const polygon_js_1 = require("../../../../../../chains/chain-definitions/polygon.js");
const addresses_js_1 = require("../../../../../../constants/addresses.js");
const useChainQuery_js_1 = require("../../../../../core/hooks/others/useChainQuery.js");
const useWalletBalance_js_1 = require("../../../../../core/hooks/others/useWalletBalance.js");
const useBuyWithCryptoQuote_js_1 = require("../../../../../core/hooks/pay/useBuyWithCryptoQuote.js");
const wallet_hooks_js_1 = require("../../../../../core/hooks/wallets/wallet-hooks.js");
const Spacer_js_1 = require("../../../components/Spacer.js");
const Spinner_js_1 = require("../../../components/Spinner.js");
const basic_js_1 = require("../../../components/basic.js");
const buttons_js_1 = require("../../../components/buttons.js");
const text_js_1 = require("../../../components/text.js");
const index_js_1 = require("../../../design-system/index.js");
const useDebouncedValue_js_1 = require("../../../hooks/useDebouncedValue.js");
const NetworkSelector_js_1 = require("../../NetworkSelector.js");
const TokenSelector_js_1 = require("../TokenSelector.js");
const nativeToken_js_1 = require("../nativeToken.js");
const PaymentSelection_js_1 = require("./PaymentSelection.js");
const BuyTokenInput_js_1 = require("./swap/BuyTokenInput.js");
const ConfirmationScreen_js_1 = require("./swap/ConfirmationScreen.js");
const PayWithCrypto_js_1 = require("./swap/PayWithCrypto.js");
const SwapFees_js_1 = require("./swap/SwapFees.js");
const useSwapSupportedChains_js_1 = require("./swap/useSwapSupportedChains.js");
/**
 * @internal
 */
function SwapScreen(props) {
    const activeChain = (0, wallet_hooks_js_1.useActiveWalletChain)();
    const account = (0, wallet_hooks_js_1.useActiveAccount)();
    if (!activeChain || !account) {
        return null; // this should never happen
    }
    return ((0, jsx_runtime_1.jsx)(SwapScreenContent, { ...props, activeChain: activeChain, account: account, onViewPendingTx: props.onViewPendingTx }));
}
exports.SwapScreen = SwapScreen;
/**
 *
 * @internal
 */
function SwapScreenContent(props) {
    const { activeChain, account, client } = props;
    const [isSwitching, setIsSwitching] = (0, react_1.useState)(false);
    const switchActiveWalletChain = (0, wallet_hooks_js_1.useSwitchActiveWalletChain)();
    const supportedChainsQuery = (0, useSwapSupportedChains_js_1.useSwapSupportedChains)(client);
    const supportedChains = supportedChainsQuery.data;
    // prefetch chains metadata
    (0, useChainQuery_js_1.useChainsQuery)(supportedChains || [], 50);
    // screens
    const [screen, setScreen] = (0, react_1.useState)("main");
    // token amount
    const [tokenAmount, setTokenAmount] = (0, react_1.useState)("");
    const [hasEditedAmount, setHasEditedAmount] = (0, react_1.useState)(false);
    const isChainSupported = (0, react_1.useMemo)(() => supportedChains?.find((c) => c.id === activeChain.id), [activeChain.id, supportedChains]);
    // selected chain
    const defaultChain = isChainSupported ? activeChain : polygon_js_1.polygon;
    const [fromChain, setFromChain] = (0, react_1.useState)(defaultChain);
    const [toChain, setToChain] = (0, react_1.useState)(defaultChain);
    // selected tokens
    const [fromToken, setFromToken] = (0, react_1.useState)(nativeToken_js_1.NATIVE_TOKEN);
    const [toToken, setToToken] = (0, react_1.useState)(props.supportedTokens[toChain.id]?.[0] || nativeToken_js_1.NATIVE_TOKEN);
    const deferredTokenAmount = (0, useDebouncedValue_js_1.useDebouncedValue)(tokenAmount, 300);
    const fromTokenBalanceQuery = (0, useWalletBalance_js_1.useWalletBalance)({
        address: account.address,
        chain: fromChain,
        tokenAddress: (0, nativeToken_js_1.isNativeToken)(fromToken) ? undefined : fromToken.address,
    });
    // when a quote is finalized ( approve sent if required or swap sent )
    // we save it here to stop refetching the quote query
    const [finalizedQuote, setFinalizedQuote] = (0, react_1.useState)();
    const buyWithCryptoParams = deferredTokenAmount &&
        !finalizedQuote &&
        !(fromChain.id === toChain.id && fromToken === toToken)
        ? {
            // wallet
            fromAddress: account.address,
            // from token
            fromChainId: fromChain.id,
            fromTokenAddress: (0, nativeToken_js_1.isNativeToken)(fromToken)
                ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                : fromToken.address,
            toChainId: toChain.id,
            // to
            toTokenAddress: (0, nativeToken_js_1.isNativeToken)(toToken)
                ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                : toToken.address,
            toAmount: deferredTokenAmount,
            client,
        }
        : undefined;
    const buyWithCryptoQuoteQuery = (0, useBuyWithCryptoQuote_js_1.useBuyWithCryptoQuote)(buyWithCryptoParams, {
        // refetch every 30 seconds
        staleTime: 30 * 1000,
        refetchInterval: 30 * 1000,
        gcTime: 30 * 1000,
    });
    if (!supportedChains) {
        return ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "row", center: "both", style: {
                minHeight: "350px",
            }, children: (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { color: "secondaryText", size: "lg" }) }));
    }
    if (screen === "select-from-token") {
        return ((0, jsx_runtime_1.jsx)(TokenSelector_js_1.TokenSelector, { onBack: () => setScreen("main"), tokenList: (fromChain?.id ? props.supportedTokens[fromChain.id] : undefined) ||
                [], onTokenSelect: (tokenInfo) => {
                setFromToken(tokenInfo);
                setScreen("main");
            }, chain: fromChain }));
    }
    if (screen === "select-to-token") {
        return ((0, jsx_runtime_1.jsx)(TokenSelector_js_1.TokenSelector, { onBack: () => setScreen("main"), tokenList: (toChain?.id ? props.supportedTokens[toChain.id] : undefined) || [], onTokenSelect: (tokenInfo) => {
                setToToken(tokenInfo);
                setScreen("main");
            }, chain: toChain }));
    }
    if (screen === "select-from-chain" || screen === "select-to-chain") {
        return ((0, jsx_runtime_1.jsx)(NetworkSelector_js_1.NetworkSelectorContent, { showTabs: false, onBack: () => setScreen("main"), 
            // pass swap supported chains
            chains: supportedChains, closeModal: () => setScreen("main"), networkSelector: {
                renderChain(renderChainProps) {
                    return ((0, jsx_runtime_1.jsx)(NetworkSelector_js_1.ChainButton, { chain: renderChainProps.chain, confirming: false, switchingFailed: false, onClick: () => {
                            const chain = renderChainProps.chain;
                            if (screen === "select-from-chain") {
                                setFromChain(chain);
                                setFromToken(nativeToken_js_1.NATIVE_TOKEN);
                            }
                            else {
                                setToChain(chain);
                                setToToken(nativeToken_js_1.NATIVE_TOKEN);
                            }
                            setScreen("main");
                        } }));
                },
            } }));
    }
    const swapQuote = buyWithCryptoQuoteQuery.data;
    const isSwapQuoteError = buyWithCryptoQuoteQuery.isError;
    const getErrorMessage = () => {
        const defaultMessage = "Unable to get price quote";
        try {
            if (buyWithCryptoQuoteQuery.error instanceof Error) {
                if (buyWithCryptoQuoteQuery.error.message.includes("Minimum")) {
                    const msg = buyWithCryptoQuoteQuery.error.message;
                    return msg.replace("Fetch failed: Error: ", "");
                }
            }
            return defaultMessage;
        }
        catch {
            return defaultMessage;
        }
    };
    const sourceTokenAmount = swapQuote?.swapDetails.fromAmount || "";
    const quoteToConfirm = finalizedQuote || buyWithCryptoQuoteQuery.data;
    if (screen === "confirmation" && quoteToConfirm) {
        return ((0, jsx_runtime_1.jsx)(ConfirmationScreen_js_1.ConfirmationScreen, { client: client, onBack: () => {
                // remove finalized quote when going back
                setFinalizedQuote(undefined);
                setScreen("main");
            }, buyWithCryptoQuote: quoteToConfirm, onQuoteFinalized: (_quote) => {
                setFinalizedQuote(_quote);
            }, fromAmount: quoteToConfirm.swapDetails.fromAmount, toAmount: tokenAmount, fromChain: fromChain, toChain: toChain, account: account, fromToken: fromToken, toToken: toToken, onViewPendingTx: props.onViewPendingTx }));
    }
    const isNotEnoughBalance = !!sourceTokenAmount &&
        !!fromTokenBalanceQuery.data &&
        Number(fromTokenBalanceQuery.data.displayValue) < Number(sourceTokenAmount);
    const disableContinue = !swapQuote || isNotEnoughBalance;
    const switchChainRequired = props.activeChain.id !== fromChain.id;
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { animate: "fadein", children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { p: "lg", children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: "Buy", onBack: props.onBack }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), !hasEditedAmount && (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), (0, jsx_runtime_1.jsx)(BuyTokenInput_js_1.BuyTokenInput, { value: tokenAmount, onChange: async (value) => {
                            setHasEditedAmount(true);
                            setTokenAmount(value);
                        }, token: toToken, chain: toChain, onChainClick: () => setScreen("select-to-chain"), onTokenClick: () => setScreen("select-to-token") })] }), !hasEditedAmount && (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xxl" }), (0, jsx_runtime_1.jsx)(basic_js_1.Line, {}), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { p: "lg", children: [hasEditedAmount && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(PaymentSelection_js_1.PaymentSelection, {}), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(PayWithCrypto_js_1.PayWithCrypto, { value: sourceTokenAmount, onTokenClick: () => setScreen("select-from-token"), chain: fromChain, token: fromToken, isLoading: buyWithCryptoQuoteQuery.isLoading && !sourceTokenAmount, onChainClick: () => setScreen("select-from-chain") }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "md", children: [buyWithCryptoQuoteQuery.data && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(SwapFees_js_1.SwapFees, { quote: buyWithCryptoQuoteQuery.data }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" })] })), isSwapQuoteError && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", center: "y", color: "danger", children: [(0, jsx_runtime_1.jsx)(react_icons_1.CrossCircledIcon, { width: index_js_1.iconSize.sm, height: index_js_1.iconSize.sm }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "danger", size: "sm", children: getErrorMessage() })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" })] }))] })] })), switchChainRequired && ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { fullWidth: true, variant: "accent", disabled: !hasEditedAmount, "data-disabled": !hasEditedAmount, gap: "sm", onClick: async () => {
                            setIsSwitching(true);
                            try {
                                await switchActiveWalletChain(fromChain);
                            }
                            catch { }
                            setIsSwitching(false);
                        }, children: hasEditedAmount ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [isSwitching && (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "sm", color: "accentButtonText" }), isSwitching ? "Switching" : "Switch Network"] })) : ("Continue") })), !switchChainRequired && ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: disableContinue ? "outline" : "accent", fullWidth: true, "data-disabled": disableContinue, disabled: disableContinue, onClick: async () => {
                            if (!disableContinue) {
                                setScreen("confirmation");
                            }
                        }, gap: "sm", children: isNotEnoughBalance ? "Not Enough Funds" : "Continue" }))] })] }));
}
exports.SwapScreenContent = SwapScreenContent;
//# sourceMappingURL=SwapScreen.js.map