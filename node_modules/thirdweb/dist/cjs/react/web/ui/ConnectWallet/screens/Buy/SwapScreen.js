"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuyScreenContent = exports.BuyScreen = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_icons_1 = require("@radix-ui/react-icons");
const react_1 = require("react");
const polygon_js_1 = require("../../../../../../chains/chain-definitions/polygon.js");
const addresses_js_1 = require("../../../../../../constants/addresses.js");
const formatNumber_js_1 = require("../../../../../../utils/formatNumber.js");
const units_js_1 = require("../../../../../../utils/units.js");
const useSendTransaction_js_1 = require("../../../../../core/hooks/contract/useSendTransaction.js");
const useChainQuery_js_1 = require("../../../../../core/hooks/others/useChainQuery.js");
const useWalletBalance_js_1 = require("../../../../../core/hooks/others/useWalletBalance.js");
const useBuyWithCryptoQuote_js_1 = require("../../../../../core/hooks/pay/useBuyWithCryptoQuote.js");
const wallet_hooks_js_1 = require("../../../../../core/hooks/wallets/wallet-hooks.js");
const wait_js_1 = require("../../../../../core/utils/wait.js");
const LoadingScreen_js_1 = require("../../../../wallets/shared/LoadingScreen.js");
const Drawer_js_1 = require("../../../components/Drawer.js");
const DynamicHeight_js_1 = require("../../../components/DynamicHeight.js");
const Skeleton_js_1 = require("../../../components/Skeleton.js");
const Spacer_js_1 = require("../../../components/Spacer.js");
const Spinner_js_1 = require("../../../components/Spinner.js");
const TokenIcon_js_1 = require("../../../components/TokenIcon.js");
const basic_js_1 = require("../../../components/basic.js");
const buttons_js_1 = require("../../../components/buttons.js");
const text_js_1 = require("../../../components/text.js");
const index_js_1 = require("../../../design-system/index.js");
const useDebouncedValue_js_1 = require("../../../hooks/useDebouncedValue.js");
const TokenSelector_js_1 = require("../TokenSelector.js");
const nativeToken_js_1 = require("../nativeToken.js");
const AccountSelectionScreen_js_1 = require("./AccountSelectionScreen.js");
const AccountSelectorButton_js_1 = require("./AccountSelectorButton.js");
const PaymentSelection_js_1 = require("./PaymentSelection.js");
const buttons_js_2 = require("./buttons.js");
const BuyTokenInput_js_1 = require("./swap/BuyTokenInput.js");
const ConfirmationScreen_js_1 = require("./swap/ConfirmationScreen.js");
const Fees_js_1 = require("./swap/Fees.js");
const PayWithCrypto_js_1 = require("./swap/PayWithCrypto.js");
const formatSeconds_js_1 = require("./swap/formatSeconds.js");
const useSwapSupportedChains_js_1 = require("./swap/useSwapSupportedChains.js");
/**
 * @internal
 */
function BuyScreen(props) {
    const activeChain = (0, wallet_hooks_js_1.useActiveWalletChain)();
    const activeWallet = (0, wallet_hooks_js_1.useActiveWallet)();
    const account = (0, wallet_hooks_js_1.useActiveAccount)();
    const supportedChainsQuery = (0, useSwapSupportedChains_js_1.useSwapSupportedChains)(props.client);
    if (!activeChain || !account || !activeWallet || !supportedChainsQuery.data) {
        return (0, jsx_runtime_1.jsx)(LoadingScreen_js_1.LoadingScreen, {});
    }
    return ((0, jsx_runtime_1.jsx)(BuyScreenContent, { ...props, activeChain: activeChain, activeWallet: activeWallet, account: account, onViewPendingTx: props.onViewPendingTx, supportedChains: supportedChainsQuery.data, buyForTx: props.buyForTx }));
}
exports.BuyScreen = BuyScreen;
/**
 *
 * @internal
 */
function BuyScreenContent(props) {
    const { activeChain, account, client, activeWallet, supportedChains, connectLocale, } = props;
    const [isSwitching, setIsSwitching] = (0, react_1.useState)(false);
    const switchActiveWalletChain = (0, wallet_hooks_js_1.useSwitchActiveWalletChain)();
    const [method] = (0, react_1.useState)("crypto");
    // prefetch chains metadata
    (0, useChainQuery_js_1.useChainsQuery)(supportedChains || [], 50);
    // screens
    const [screen, setScreen] = (0, react_1.useState)("main");
    const [drawerScreen, setDrawerScreen] = (0, react_1.useState)();
    const { drawerRef, drawerOverlayRef, onClose } = (0, Drawer_js_1.useDrawer)();
    const closeDrawer = () => {
        onClose(() => {
            setDrawerScreen(undefined);
        });
    };
    const initialTokenAmount = props.buyForTx
        ? (0, formatNumber_js_1.formatNumber)(Number((0, units_js_1.toEther)(props.buyForTx.cost - props.buyForTx.balance)), 4)
        : undefined;
    // token amount
    const [tokenAmount, setTokenAmount] = (0, react_1.useState)(initialTokenAmount ? String(initialTokenAmount) : "");
    // once the user edits the tokenInput or confirms the Buy - stop updating the token amount
    const [stopUpdatingTokenAmount, setStopUpdatingTokenAmount] = (0, react_1.useState)(!props.buyForTx);
    const [amountNeeded, setAmountNeeded] = (0, react_1.useState)(props.buyForTx?.cost);
    // update amount needed every 30 seconds
    // also update the token amount if allowed
    // ( Can't use useQuery because tx can't be added to queryKey )
    (0, react_1.useEffect)(() => {
        const buyTx = props.buyForTx;
        if (!buyTx || stopUpdatingTokenAmount) {
            return;
        }
        let mounted = true;
        async function pollTxCost() {
            if (!buyTx || !mounted) {
                return;
            }
            try {
                const totalCost = await (0, useSendTransaction_js_1.getTotalTxCostForBuy)(buyTx.tx);
                if (!mounted) {
                    return;
                }
                setAmountNeeded(totalCost);
                if (totalCost > buyTx.balance) {
                    const _tokenAmount = String((0, formatNumber_js_1.formatNumber)(Number((0, units_js_1.toEther)(totalCost - buyTx.balance)), 4));
                    setTokenAmount(_tokenAmount);
                }
            }
            catch {
                // no op
            }
            await (0, wait_js_1.wait)(30000);
            pollTxCost();
        }
        pollTxCost();
        return () => {
            mounted = false;
        };
    }, [props.buyForTx, stopUpdatingTokenAmount]);
    const [hasEditedAmount, setHasEditedAmount] = (0, react_1.useState)(false);
    const isMiniScreen = props.buyForTx ? false : !hasEditedAmount;
    const isChainSupported = (0, react_1.useMemo)(() => supportedChains?.find((c) => c.id === activeChain.id), [activeChain.id, supportedChains]);
    // selected chain
    const defaultChain = isChainSupported ? activeChain : polygon_js_1.polygon;
    const [fromChain, setFromChain] = (0, react_1.useState)(props.buyForTx ? props.buyForTx.tx.chain : defaultChain);
    const [toChain, setToChain] = (0, react_1.useState)(props.buyForTx ? props.buyForTx.tx.chain : defaultChain);
    const [address, setAddress] = (0, react_1.useState)(account.address);
    // selected tokens
    const [fromToken, setFromToken] = (0, react_1.useState)((props.buyForTx ? props.supportedTokens[toChain.id]?.[0] : undefined) ||
        nativeToken_js_1.NATIVE_TOKEN);
    const [toToken, setToToken] = (0, react_1.useState)(props.buyForTx
        ? nativeToken_js_1.NATIVE_TOKEN
        : props.supportedTokens[toChain.id]?.[0] || nativeToken_js_1.NATIVE_TOKEN);
    const deferredTokenAmount = (0, useDebouncedValue_js_1.useDebouncedValue)(tokenAmount, 300);
    const fromTokenBalanceQuery = (0, useWalletBalance_js_1.useWalletBalance)({
        address: account.address,
        chain: fromChain,
        tokenAddress: (0, nativeToken_js_1.isNativeToken)(fromToken) ? undefined : fromToken.address,
        client,
    });
    // when a quote is finalized ( approve sent if required or swap sent )
    // we save it here to stop refetching the quote query
    const [finalizedQuote, setFinalizedQuote] = (0, react_1.useState)();
    const buyWithCryptoParams = deferredTokenAmount &&
        !finalizedQuote &&
        !(fromChain.id === toChain.id && fromToken === toToken)
        ? {
            // wallet
            fromAddress: address,
            // from token
            fromChainId: fromChain.id,
            fromTokenAddress: (0, nativeToken_js_1.isNativeToken)(fromToken)
                ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                : fromToken.address,
            toChainId: toChain.id,
            // to
            toTokenAddress: (0, nativeToken_js_1.isNativeToken)(toToken)
                ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                : toToken.address,
            toAmount: deferredTokenAmount,
            client,
        }
        : undefined;
    const buyWithCryptoQuoteQuery = (0, useBuyWithCryptoQuote_js_1.useBuyWithCryptoQuote)(buyWithCryptoParams, {
        // refetch every 30 seconds
        staleTime: 30 * 1000,
        refetchInterval: 30 * 1000,
        gcTime: 30 * 1000,
    });
    if (screen === "select-from-token") {
        return ((0, jsx_runtime_1.jsx)(TokenSelector_js_1.TokenSelector, { onBack: () => setScreen("main"), tokenList: (fromChain?.id ? props.supportedTokens[fromChain.id] : undefined) ||
                [], onTokenSelect: (tokenInfo) => {
                setFromToken(tokenInfo);
                setScreen("main");
            }, chain: fromChain, chainSelection: {
                chains: supportedChains,
                select: (c) => setFromChain(c),
            }, connectLocale: connectLocale, client: client }));
    }
    if (screen === "select-to-token") {
        return ((0, jsx_runtime_1.jsx)(TokenSelector_js_1.TokenSelector, { onBack: () => setScreen("main"), tokenList: (toChain?.id ? props.supportedTokens[toChain.id] : undefined) || [], onTokenSelect: (tokenInfo) => {
                setToToken(tokenInfo);
                setScreen("main");
            }, chain: toChain, chainSelection: {
                chains: supportedChains,
                select: (c) => setToChain(c),
            }, connectLocale: connectLocale, client: client }));
    }
    const swapQuote = buyWithCryptoQuoteQuery.data;
    const isSwapQuoteError = buyWithCryptoQuoteQuery.isError;
    const getErrorMessage = () => {
        const defaultMessage = "Unable to get price quote";
        try {
            if (buyWithCryptoQuoteQuery.error instanceof Error) {
                if (buyWithCryptoQuoteQuery.error.message.includes("Minimum")) {
                    const msg = buyWithCryptoQuoteQuery.error.message;
                    return msg.replace("Fetch failed: Error: ", "");
                }
            }
            return defaultMessage;
        }
        catch {
            return defaultMessage;
        }
    };
    const sourceTokenAmount = swapQuote?.swapDetails.fromAmount || "";
    const quoteToConfirm = finalizedQuote || buyWithCryptoQuoteQuery.data;
    if (screen === "confirmation" && quoteToConfirm) {
        return ((0, jsx_runtime_1.jsx)(ConfirmationScreen_js_1.SwapConfirmationScreen, { client: client, onBack: () => {
                // remove finalized quote when going back
                setFinalizedQuote(undefined);
                setStopUpdatingTokenAmount(true);
                setScreen("main");
            }, buyWithCryptoQuote: quoteToConfirm, onQuoteFinalized: (_quote) => {
                setFinalizedQuote(_quote);
            }, fromAmount: quoteToConfirm.swapDetails.fromAmount, toAmount: tokenAmount, fromChain: fromChain, toChain: toChain, account: account, fromToken: fromToken, toToken: toToken, onViewPendingTx: props.onViewPendingTx }));
    }
    const isNotEnoughBalance = !!sourceTokenAmount &&
        !!fromTokenBalanceQuery.data &&
        Number(fromTokenBalanceQuery.data.displayValue) < Number(sourceTokenAmount);
    const disableContinue = !swapQuote || isNotEnoughBalance;
    const switchChainRequired = props.activeChain.id !== fromChain.id;
    return ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { animate: "fadein", children: (0, jsx_runtime_1.jsxs)("div", { onClick: (e) => {
                if (drawerScreen &&
                    drawerRef.current &&
                    !drawerRef.current.contains(e.target)) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeDrawer();
                }
            }, children: [drawerScreen && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Drawer_js_1.DrawerOverlay, { ref: drawerOverlayRef }), (0, jsx_runtime_1.jsx)(Drawer_js_1.Drawer, { ref: drawerRef, close: closeDrawer, children: (0, jsx_runtime_1.jsxs)(DynamicHeight_js_1.DynamicHeight, { children: [drawerScreen === "address" && ((0, jsx_runtime_1.jsx)(AccountSelectionScreen_js_1.AccountSelectionScreen, { onSelect: (v) => {
                                            setAddress(v);
                                            closeDrawer();
                                        }, activeAccount: account, activeWallet: props.activeWallet, client: client })), method === "crypto" && ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: drawerScreen === "fees" && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "lg", color: "primaryText", children: "Fees" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), swapQuote && ((0, jsx_runtime_1.jsx)(Fees_js_1.SwapFees, { quote: swapQuote, align: "left" }))] })) }))] }) })] })), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { p: "lg", style: {
                        paddingBottom: 0,
                    }, children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: props.buyForTx
                                ? `Not enough ${props.buyForTx.tokenSymbol}`
                                : "Buy", onBack: props.onBack }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), isMiniScreen && (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), amountNeeded && props.buyForTx ? ((0, jsx_runtime_1.jsx)(BuyForTxUI, { amountNeeded: String((0, formatNumber_js_1.formatNumber)(Number((0, units_js_1.toEther)(amountNeeded)), 4)), buyForTx: props.buyForTx, client: client })) : null, (0, jsx_runtime_1.jsx)(BuyTokenInput_js_1.BuyTokenInput, { value: tokenAmount, onChange: async (value) => {
                                setHasEditedAmount(true);
                                setStopUpdatingTokenAmount(true);
                                setTokenAmount(value);
                            }, token: toToken, chain: toChain, onSelectToken: () => setScreen("select-to-token"), client: props.client, hideTokenSelector: !!props.buyForTx })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { px: "lg", children: [!isMiniScreen && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(PaymentSelection_js_1.PaymentSelection, {}), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), method === "crypto" && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(PayWithCrypto_js_1.PayWithCrypto, { value: sourceTokenAmount, onSelectToken: () => {
                                                setScreen("select-from-token");
                                            }, chain: fromChain, token: fromToken, isLoading: buyWithCryptoQuoteQuery.isLoading && !sourceTokenAmount, client: client }), (0, jsx_runtime_1.jsx)(SecondaryInfo, { quoteIsLoading: buyWithCryptoQuoteQuery.isLoading, estimatedSeconds: buyWithCryptoQuoteQuery.data?.swapDetails.estimated
                                                .durationSeconds, onViewFees: () => setDrawerScreen("fees") })] })), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), !props.buyForTx && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", children: "Send To" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xxs" }), (0, jsx_runtime_1.jsx)(AccountSelectorButton_js_1.AccountSelectorButton, { address: address, activeAccount: account, activeWallet: activeWallet, onClick: () => {
                                                        setDrawerScreen("address");
                                                    }, chevron: true, client: client })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "md", children: method === "crypto" && isSwapQuoteError && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xxs", center: "both", color: "danger", children: [(0, jsx_runtime_1.jsx)(react_icons_1.CrossCircledIcon, { width: index_js_1.iconSize.sm, height: index_js_1.iconSize.sm }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "danger", size: "sm", children: getErrorMessage() })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })) })] })), method === "crypto" && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [switchChainRequired && ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { fullWidth: true, variant: "accent", disabled: isMiniScreen, "data-disabled": isMiniScreen, gap: "sm", onClick: async () => {
                                        setIsSwitching(true);
                                        try {
                                            await switchActiveWalletChain(fromChain);
                                        }
                                        catch { }
                                        setIsSwitching(false);
                                    }, children: !isMiniScreen ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [isSwitching && ((0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "sm", color: "accentButtonText" })), isSwitching ? "Switching" : "Switch Network"] })) : ("Continue") })), !switchChainRequired && ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: disableContinue ? "outline" : "accent", fullWidth: true, "data-disabled": disableContinue, disabled: disableContinue, onClick: async () => {
                                        if (!disableContinue) {
                                            setScreen("confirmation");
                                        }
                                    }, gap: "sm", children: isNotEnoughBalance ? "Not Enough Funds" : "Continue" }))] })), method === "creditCard" && ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "accent", fullWidth: true, onClick: async () => {
                                setScreen("kado-iframe");
                            }, gap: "sm", children: "Continue" }))] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" })] }) }));
}
exports.BuyScreenContent = BuyScreenContent;
const ViewFeeIcon = (props) => {
    return ((0, jsx_runtime_1.jsxs)("svg", { width: props.size, height: props.size, viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", children: [(0, jsx_runtime_1.jsx)("path", { d: "M9.5 1.5H2.5C1.94772 1.5 1.5 1.94772 1.5 2.5V9.5C1.5 10.0523 1.94772 10.5 2.5 10.5H9.5C10.0523 10.5 10.5 10.0523 10.5 9.5V2.5C10.5 1.94772 10.0523 1.5 9.5 1.5Z", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }), (0, jsx_runtime_1.jsx)("path", { d: "M4.5 7.5L7.5 4.5", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" })] }));
};
function SecondaryInfo(props) {
    const { estimatedSeconds, quoteIsLoading } = props;
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { bg: "tertiaryBg", flex: "row", borderColor: "borderColor", style: {
            borderRadius: index_js_1.radius.md,
            borderTopLeftRadius: 0,
            borderTopRightRadius: 0,
            justifyContent: "space-between",
            alignItems: "center",
            borderWidth: "1px",
            borderStyle: "solid",
        }, children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", center: "y", gap: "xxs", color: "accentText", p: "sm", children: [(0, jsx_runtime_1.jsx)(react_icons_1.ClockIcon, { width: index_js_1.iconSize.sm, height: index_js_1.iconSize.sm }), quoteIsLoading ? ((0, jsx_runtime_1.jsx)(Skeleton_js_1.Skeleton, { height: index_js_1.fontSize.xs, width: "50px", color: "borderColor" })) : ((0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", color: "secondaryText", children: estimatedSeconds !== undefined
                            ? `~${(0, formatSeconds_js_1.formatSeconds)(estimatedSeconds)}`
                            : "--" }))] }), (0, jsx_runtime_1.jsxs)(buttons_js_2.FeesButton, { variant: "secondary", onClick: props.onViewFees, children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { color: "accentText", flex: "row", center: "both", children: (0, jsx_runtime_1.jsx)(ViewFeeIcon, { size: index_js_1.iconSize.sm }) }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", color: "secondaryText", children: "View Fees" })] })] }));
}
function BuyForTxUI(props) {
    const chainQuery = (0, useChainQuery_js_1.useChainQuery)(props.buyForTx.tx.chain);
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xs" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", style: {
                    justifyContent: "space-between",
                }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", children: "Amount Needed" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", style: {
                            alignItems: "flex-end",
                        }, children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", center: "y", children: [(0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "primaryText", size: "sm", children: [props.amountNeeded, " ", props.buyForTx.tokenSymbol] }), (0, jsx_runtime_1.jsx)(TokenIcon_js_1.TokenIcon, { chain: props.buyForTx.tx.chain, client: props.client, size: "sm", token: nativeToken_js_1.NATIVE_TOKEN })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xxs" }), chainQuery.data ? ((0, jsx_runtime_1.jsxs)(text_js_1.Text, { size: "sm", children: [" ", chainQuery.data.name] })) : ((0, jsx_runtime_1.jsx)(Skeleton_js_1.Skeleton, { height: index_js_1.fontSize.sm, width: "50px" }))] })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsx)(basic_js_1.Line, {}), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", style: {
                    justifyContent: "space-between",
                }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", children: "Your Balance" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", children: [(0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "primaryText", size: "sm", children: [(0, formatNumber_js_1.formatNumber)(Number((0, units_js_1.toEther)(props.buyForTx.balance)), 4), " ", props.buyForTx.tokenSymbol] }), (0, jsx_runtime_1.jsx)(TokenIcon_js_1.TokenIcon, { chain: props.buyForTx.tx.chain, client: props.client, size: "sm", token: nativeToken_js_1.NATIVE_TOKEN })] })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsx)(basic_js_1.Line, {}), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { center: true, size: "sm", children: "Purchase" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xxs" })] }));
}
//# sourceMappingURL=SwapScreen.js.map