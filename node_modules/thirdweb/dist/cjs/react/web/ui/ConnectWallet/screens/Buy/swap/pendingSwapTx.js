"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPendingSwapTransaction = exports.swapTransactionsStore = void 0;
const getStatus_js_1 = require("../../../../../../../pay/buyWithCrypto/actions/getStatus.js");
const store_js_1 = require("../../../../../../../reactive/store.js");
const wait_js_1 = require("../../../../../../../utils/promise/wait.js");
// array of transaction hashes
exports.swapTransactionsStore = (0, store_js_1.createStore)([]);
/**
 * @internal
 */
const addPendingSwapTransaction = (client, txInfo) => {
    const currentValue = exports.swapTransactionsStore.getValue();
    const indexAdded = currentValue.length;
    // add it
    exports.swapTransactionsStore.setValue([...currentValue, txInfo]);
    // poll for it's status and update the store when we know it's status
    const maxRetries = 50;
    let retryCount = 0;
    async function tryToGetStatus() {
        // keep polling for the transaction status every 5 seconds until maxRetries
        await (0, wait_js_1.wait)(5000);
        try {
            retryCount++;
            const res = await (0, getStatus_js_1.getBuyWithCryptoStatus)({
                client: client,
                transactionHash: txInfo.transactionHash,
            });
            if (res.status === "COMPLETED" || res.status === "FAILED") {
                const value = exports.swapTransactionsStore.getValue();
                const updatedValue = [...value];
                const oldValue = value[indexAdded];
                if (oldValue) {
                    const newValue = {
                        ...oldValue,
                        status: res.status,
                        subStatus: res.subStatus,
                    };
                    updatedValue[indexAdded] = newValue;
                    // in case - the destination token is different ( happens when tx is partially successful )
                    if (res.destination) {
                        newValue.to = {
                            symbol: res.destination.token.symbol || "",
                            value: res.destination.amount,
                        };
                    }
                    exports.swapTransactionsStore.setValue(updatedValue);
                }
                return; // stop
            }
        }
        catch {
            // ignore
        }
        if (retryCount < maxRetries) {
            await tryToGetStatus();
        }
    }
    tryToGetStatus();
};
exports.addPendingSwapTransaction = addPendingSwapTransaction;
//# sourceMappingURL=pendingSwapTx.js.map