"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.aesDecryptCompat = exports.aesDecrypt = void 0;
const text_decoder_js_1 = require("../../utils/text-decoder.js");
const text_encoder_js_1 = require("../../utils/text-encoder.js");
const uint8_array_js_1 = require("../../utils/uint8-array.js");
const universal_crypto_js_1 = require("./lib/universal-crypto.js");
const crypto_js_compat_js_1 = require("./utils/crypto-js-compat.js");
/**
 * Decrypts ciphertext encrypted with aesEncrypt() using supplied password.
 * @param    ciphertext - Ciphertext to be decrypted.
 * @param    password - Password to use to decrypt ciphertext.
 * @returns  Decrypted plaintext.
 * @example
 *   const plaintext = await aesDecrypt(ciphertext, 'pw');
 */
async function aesDecrypt(ciphertext, password) {
    const crypto = await (0, universal_crypto_js_1.universalCrypto)();
    // encode password as UTF-8
    const pwUtf8 = (0, text_encoder_js_1.cachedTextEncoder)().encode(password);
    // hash the password
    const pwHash = await crypto.subtle.digest("SHA-256", pwUtf8);
    const cipherUint8Array = (0, uint8_array_js_1.base64ToUint8Array)(ciphertext);
    // iv
    const iv = cipherUint8Array.slice(0, 12);
    // specify algorithm to use
    const alg = { name: "AES-GCM", iv };
    // generate key from pw
    const key = await crypto.subtle.importKey("raw", pwHash, alg, false, [
        "decrypt",
    ]);
    // ciphertext
    const ctUint8 = cipherUint8Array.slice(12);
    try {
        // decrypt ciphertext using key
        const plainBuffer = await crypto.subtle.decrypt(alg, key, ctUint8);
        // return the plaintext from ArrayBuffer
        return (0, text_decoder_js_1.cachedTextDecoder)().decode(plainBuffer);
    }
    catch (e) {
        throw new Error("Decrypt failed");
    }
}
exports.aesDecrypt = aesDecrypt;
/**
 * Decrypts ciphertext encrypted with aesEncrypt() OR "crypto-js".AES using supplied password.
 * @param    ciphertext - Ciphertext to be decrypted.
 * @param    password - Password to use to decrypt ciphertext.
 * @returns  Decrypted plaintext.
 * @example
 *   const plaintext = await aesDecryptCompat(ciphertext, 'pw');
 */
async function aesDecryptCompat(ciphertext, password) {
    // determine if we're dealing with a legacy (cryptojs) ciphertext
    const cryptoJs = (0, crypto_js_compat_js_1.parseCryptoJSCipherBase64)(ciphertext);
    if (cryptoJs.salt && cryptoJs.ciphertext) {
        return (0, crypto_js_compat_js_1.decryptCryptoJSCipherBase64)(cryptoJs.salt, cryptoJs.ciphertext, password);
    }
    // otherwise assume it's a ciphertext generated by aesEncrypt()
    return aesDecrypt(ciphertext, password);
}
exports.aesDecryptCompat = aesDecryptCompat;
//# sourceMappingURL=decrypt.js.map