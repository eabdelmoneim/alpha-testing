"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCryptoJSCipherBase64 = exports.decryptCryptoJSCipherBase64 = void 0;
const text_decoder_js_1 = require("../../../utils/text-decoder.js");
const text_encoder_js_1 = require("../../../utils/text-encoder.js");
const uint8_array_js_1 = require("../../../utils/uint8-array.js");
const md5_js_1 = require("../lib/md5.js");
const universal_crypto_js_1 = require("../lib/universal-crypto.js");
/**
 * This is an implementation of the CryptoJS AES decryption scheme, without actually relying on crypto-js.
 */
const HEAD_SIZE_DWORD = 2;
const SALT_SIZE_DWORD = 2;
/**
 * @internal
 */
async function decryptCryptoJSCipherBase64(salt, ciphertext, password, { keySizeDWORD = 256 / 32, ivSizeDWORD = 128 / 32, iterations = 1 } = {}) {
    const crypto = await (0, universal_crypto_js_1.universalCrypto)();
    const { key, iv } = await dangerouslyDeriveParameters(password, salt, keySizeDWORD, ivSizeDWORD, iterations);
    try {
        // decrypt ciphertext using key
        const plainBuffer = await crypto.subtle.decrypt({ name: "AES-CBC", iv }, key, ciphertext);
        // return the plaintext from ArrayBuffer
        return (0, text_decoder_js_1.cachedTextDecoder)().decode(plainBuffer);
    }
    catch (e) {
        throw new Error("Decrypt failed");
    }
}
exports.decryptCryptoJSCipherBase64 = decryptCryptoJSCipherBase64;
/**
 * @internal
 */
function parseCryptoJSCipherBase64(cryptoJSCipherBase64) {
    let salt = null;
    let ciphertext = (0, uint8_array_js_1.base64ToUint8Array)(cryptoJSCipherBase64);
    const [head, body] = splitUint8Array(ciphertext, HEAD_SIZE_DWORD * 4);
    if (!head || !body) {
        throw new Error("Invalid ciphertext");
    }
    // This effectively checks if the ciphertext starts with 'Salted__', which is the crypto-js convention.
    const headDataView = new DataView(head.buffer);
    if (headDataView.getInt32(0) === 0x53616c74 &&
        headDataView.getInt32(4) === 0x65645f5f) {
        const [_salt, _ciphertext] = splitUint8Array(body, SALT_SIZE_DWORD * 4);
        if (!_salt || !_ciphertext) {
            throw new Error("Invalid ciphertext");
        }
        salt = _salt;
        ciphertext = _ciphertext;
    }
    return { ciphertext, salt };
}
exports.parseCryptoJSCipherBase64 = parseCryptoJSCipherBase64;
async function dangerouslyDeriveParameters(password, salt, keySizeDWORD, ivSizeDWORD, iterations) {
    const crypto = await (0, universal_crypto_js_1.universalCrypto)();
    const passwordUint8Array = (0, text_encoder_js_1.cachedTextEncoder)().encode(password);
    const keyPlusIV = dangerousEVPKDF(passwordUint8Array, salt, keySizeDWORD + ivSizeDWORD, iterations);
    const [rawKey, iv] = splitUint8Array(keyPlusIV, keySizeDWORD * 4);
    if (!rawKey) {
        throw new Error("Invalid key");
    }
    const key = await crypto.subtle.importKey("raw", rawKey, "AES-CBC", false, [
        "decrypt",
    ]);
    return { key, iv };
}
function dangerousEVPKDF(passwordUint8Array, saltUint8Array, keySizeDWORD, iterations) {
    let derivedKey = new Uint8Array();
    let block = new Uint8Array();
    while (derivedKey.byteLength < keySizeDWORD * 4) {
        block = new Uint8Array((0, md5_js_1.arrayBuffer)((0, uint8_array_js_1.concatUint8Arrays)([block, passwordUint8Array, saltUint8Array])));
        for (let i = 1; i < iterations; i++) {
            block = new Uint8Array((0, md5_js_1.arrayBuffer)(block));
        }
        derivedKey = (0, uint8_array_js_1.concatUint8Arrays)([derivedKey, block]);
    }
    return derivedKey;
}
function splitUint8Array(a, i) {
    return [a.subarray(0, i), a.subarray(i, a.length)];
}
//# sourceMappingURL=crypto-js-compat.js.map