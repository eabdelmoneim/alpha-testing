"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toEthersSigner = exports.ethers6Adapter = void 0;
const universalethers = require("ethers");
const normalizeChainId_js_1 = require("../wallets/utils/normalizeChainId.js");
const resolve_promised_value_js_1 = require("../utils/promise/resolve-promised-value.js");
const utils_js_1 = require("../chains/utils.js");
const contract_js_1 = require("../contract/contract.js");
const hex_js_1 = require("../utils/encoding/hex.js");
/**
 * Checks if the given ethers object is of type ethers5.
 * @param ethers - The ethers object to check.
 * @returns True if the ethers object is of type ethers5, false otherwise.
 * @internal
 */
function isEthers5(ethers_) {
    return "providers" in ethers_;
}
/**
 * Asserts that the provided ethers object is of type ethers5.
 * If the object is not of type ethers5, an error is thrown.
 * @param ethers - The ethers object to be asserted.
 * @throws Error - If the ethers object is not of type ethers5.
 * @internal
 */
function assertEthers6(ethers_) {
    if (isEthers5(ethers_)) {
        throw new Error("You seem to be using ethers@5, please use the `ethers5Adapter()");
    }
}
exports.ethers6Adapter = (() => {
    const ethers = universalethers;
    return {
        provider: {
            /**
             * Converts a Thirdweb client and chain ID into an ethers.js provider.
             * @param client - The Thirdweb client.
             * @param chain - The chain.
             * @returns The ethers.js provider.
             * @example
             * ```ts
             * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
             * const provider = ethers6Adapter.provider.toEthers(client, chainId);
             * ```
             */
            toEthers: (client, chain) => {
                assertEthers6(ethers);
                return toEthersProvider(ethers, client, chain);
            },
        },
        contract: {
            /**
             * Converts a ThirdwebContract to an ethers.js Contract.
             * @param twContract - The ThirdwebContract to convert.
             * @returns A Promise that resolves to an ethers.js Contract.
             * @example
             * ```ts
             * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
             * const ethersContract = await ethers6Adapter.contract.toEthers(twContract);
             * ```
             */
            toEthers: (twContract) => {
                assertEthers6(ethers);
                return toEthersContract(ethers, twContract);
            },
            /**
             * Creates a ThirdwebContract instance from an ethers.js contract.
             * @param options - The options for creating the ThirdwebContract instance.
             * @returns A promise that resolves to a ThirdwebContract instance.
             * @example
             * ```ts
             * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
             *
             * const twContract = await ethers6Adapter.contract.fromEthersContract({
             *  client,
             *  ethersContract,
             *  chainId,
             * });
             * ```
             */
            fromEthers: (options) => {
                assertEthers6(ethers);
                return fromEthersContract(options);
            },
        },
        signer: {
            /**
             * Converts an ethers6 Signer into an Wallet object.
             * @param signer - The ethers6 Signer object.
             * @returns - A Promise that resolves to an Wallet object.
             * @example
             * ```ts
             * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
             * const wallet = await ethers6Adapter.signer.fromEthersSigner(signer);
             * ```
             */
            fromEthers: (signer) => {
                assertEthers6(ethers);
                return fromEthersSigner(signer);
            },
            /**
             * Converts a Thirdweb wallet to an ethers.js signer.
             * @param client - The thirdweb client.
             * @param account - The account.
             * @param chain - The chain.
             * @returns A promise that resolves to an ethers.js signer.
             * @example
             * ```ts
             * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
             * const signer = await ethers6Adapter.signer.toEthers(client, chain, account);
             * ```
             */
            toEthers: (client, account, chain) => {
                assertEthers6(ethers);
                return toEthersSigner(ethers, client, account, chain);
            },
        },
    };
})();
/**
 * Converts a Thirdweb client and chain ID into an ethers.js provider.
 * @param ethers - The ethers.js library instance.
 * @param client - The Thirdweb client.
 * @param chain - The chain.
 * @returns The ethers.js provider.
 * @internal
 */
function toEthersProvider(ethers, client, chain) {
    const url = (0, utils_js_1.getRpcUrlForChain)({ client, chain });
    const fetchRequest = new ethers.FetchRequest(url);
    if (client.secretKey) {
        fetchRequest.setHeader("x-secret-key", client.secretKey);
        fetchRequest.setHeader("Content-Type", "application/json");
    }
    return new ethers.JsonRpcProvider(fetchRequest, chain.id, {
        staticNetwork: true,
    });
}
/**
 * Converts a ThirdwebContract to an ethers.js Contract.
 * @param ethers - The ethers.js instance.
 * @param twContract - The ThirdwebContract to convert.
 * @returns A Promise that resolves to an ethers.js Contract.
 * @internal
 */
async function toEthersContract(ethers, twContract) {
    if (twContract.abi) {
        return new ethers.Contract(twContract.address, JSON.stringify(twContract.abi), toEthersProvider(ethers, twContract.client, twContract.chain));
    }
    const { resolveContractAbi } = await Promise.resolve().then(() => require("../contract/actions/resolve-abi.js"));
    const abi = await resolveContractAbi(twContract);
    return new ethers.Contract(twContract.address, JSON.stringify(abi), toEthersProvider(ethers, twContract.client, twContract.chain));
}
/**
 * Creates a ThirdwebContract instance from an ethers.js contract.
 * @param options - The options for creating the ThirdwebContract instance.
 * @returns A promise that resolves to a ThirdwebContract instance.
 * @internal
 */
async function fromEthersContract({ client, ethersContract, chain, }) {
    return (0, contract_js_1.getContract)({
        client,
        address: await ethersContract.getAddress(),
        abi: JSON.parse(ethersContract.interface.formatJson()),
        chain,
    });
}
/**
 * Converts an ethers5 Signer into an Account object.
 * @param signer - The ethers5 Signer object.
 * @returns - A Promise that resolves to an Account object.
 * @internal
 */
async function fromEthersSigner(signer) {
    const address = await signer.getAddress();
    const account = {
        address,
        signMessage: async ({ message }) => {
            return signer.signMessage(typeof message === "string" ? message : message.raw);
        },
        signTransaction: async (tx) => {
            return signer.signTransaction(alignTxToEthers(tx));
        },
        sendTransaction: async (tx) => {
            const transactionHash = (await signer.sendTransaction(alignTxToEthers(tx))).hash;
            return {
                transactionHash,
            };
        },
        signTypedData: async (data) => {
            return (await signer.signTypedData(data.domain, data.types, data.message));
        },
    };
    return account;
}
/**
 * Converts a Thirdweb account to an ethers.js signer.
 * @param ethers - The ethers.js library.
 * @param client - The Thirdweb client.
 * @param chain - The blockchain chain.
 * @param account - The Thirdweb account.
 * @returns A promise that resolves to an ethers.js signer.
 * @internal
 */
async function toEthersSigner(ethers, client, account, chain) {
    class ThirdwebAdapterSigner extends ethers.AbstractSigner {
        // eslint-disable-next-line jsdoc/require-jsdoc
        constructor(provider, address) {
            super(provider);
            Object.defineProperty(this, "address", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "provider", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.address = address;
            this.provider = provider;
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        async getAddress() {
            // needs to be a promise because ethers6 returns a promise
            return this.address;
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        connect() {
            return this;
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        async sendTransaction(tx) {
            const alignedTx = await alignTxFromEthers(tx);
            if (!account) {
                throw new Error("Account not found");
            }
            const result = await account.sendTransaction({
                ...alignedTx,
                chainId: tx.chainId,
            });
            const txResponseParams = {
                ...alignedTx,
                blockHash: null,
                from: this.address,
                hash: result.transactionHash,
                blockNumber: null,
                index: 0,
                gasLimit: alignedTx.gas,
                // @ts-expect-error - we don't have this reliably so we'll just not include it
                signature: null,
            };
            return new ethers.TransactionResponse(txResponseParams, this.provider);
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        async signTransaction(tx) {
            if (!account) {
                throw new Error("Account not found");
            }
            if (!account.signTransaction) {
                throw new Error("Account does not support signing transactions");
            }
            const viemTx = await alignTxFromEthers(tx);
            return account.signTransaction(viemTx);
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        signMessage(message) {
            if (!account) {
                throw new Error("Account not found");
            }
            return account.signMessage({
                message: typeof message === "string" ? message : (0, hex_js_1.uint8ArrayToHex)(message),
            });
        }
        // eslint-disable-next-line jsdoc/require-jsdoc
        signTypedData(domain, types, value) {
            if (!account) {
                throw new Error("Account not found");
            }
            const typedDataEncoder = new ethers.TypedDataEncoder(types);
            const typedData = {
                primaryType: typedDataEncoder.primaryType,
                domain: {
                    chainId: domain.chainId
                        ? bigNumberIshToNumber(domain.chainId)
                        : undefined,
                    name: domain.name ?? undefined,
                    salt: domain.salt ? (0, hex_js_1.toHex)(domain.salt) : undefined,
                    verifyingContract: domain.verifyingContract ?? undefined,
                    version: domain.version ?? undefined,
                },
                types,
                message: value,
            };
            return account.signTypedData(typedData);
        }
    }
    return new ThirdwebAdapterSigner(toEthersProvider(ethers, client, chain), account.address);
}
exports.toEthersSigner = toEthersSigner;
/**
 * Aligns a transaction object to fit the format expected by ethers6 library.
 * @param tx - The transaction object to align.
 * @returns The aligned transaction object.
 * @internal
 */
function alignTxToEthers(tx) {
    const { type: viemType, ...rest } = tx;
    // massage "type" to fit ethers
    let type;
    switch (viemType) {
        case "legacy": {
            type = 0;
            break;
        }
        case "eip2930": {
            type = 1;
            break;
        }
        case "eip1559": {
            type = 2;
            break;
        }
        default: {
            type = null;
            break;
        }
    }
    return { ...rest, type };
}
async function alignTxFromEthers(tx) {
    const { type: ethersType, accessList, chainId: ethersChainId, to: ethersTo, data, nonce, value, gasPrice, gasLimit, maxFeePerGas, maxPriorityFeePerGas, } = tx;
    let chainId;
    if (ethersChainId) {
        chainId = (0, normalizeChainId_js_1.normalizeChainId)(ethersChainId);
    }
    const to = await resolveEthers6Address(ethersTo);
    // massage "type" to fit ethers
    switch (ethersType) {
        case 1: {
            if (!chainId) {
                throw new Error("ChainId is required for EIP-2930 transactions");
            }
            return {
                type: "eip2930",
                chainId,
                accessList: accessList,
                to,
                data: (data ?? undefined),
                gasPrice: gasPrice ? bigNumberIshToBigint(gasPrice) : undefined,
                gas: gasLimit ? bigNumberIshToBigint(gasLimit) : undefined,
                nonce: nonce ?? undefined,
                value: value ? bigNumberIshToBigint(value) : undefined,
            };
        }
        case 2: {
            if (!chainId) {
                throw new Error("ChainId is required for EIP-1559 transactions");
            }
            return {
                type: "eip1559",
                chainId,
                accessList: accessList,
                to,
                data: (data ?? undefined),
                gas: gasLimit ? bigNumberIshToBigint(gasLimit) : undefined,
                nonce: nonce ?? undefined,
                value: value ? bigNumberIshToBigint(value) : undefined,
                maxFeePerGas: maxFeePerGas
                    ? bigNumberIshToBigint(maxFeePerGas)
                    : undefined,
                maxPriorityFeePerGas: maxPriorityFeePerGas
                    ? bigNumberIshToBigint(maxPriorityFeePerGas)
                    : undefined,
            };
        }
        case 0:
        default: {
            // fall back to legacy
            return {
                type: "legacy",
                chainId,
                to,
                data: (data ?? undefined),
                nonce: nonce ?? undefined,
                value: value ? bigNumberIshToBigint(value) : undefined,
                gasPrice: gasPrice ? bigNumberIshToBigint(gasPrice) : undefined,
                gas: gasLimit ? bigNumberIshToBigint(gasLimit) : undefined,
            };
        }
    }
}
async function resolveEthers6Address(address) {
    if (!address) {
        return address;
    }
    address = await (0, resolve_promised_value_js_1.resolvePromisedValue)(address);
    if (typeof address === "string") {
        return address;
    }
    return address.getAddress();
}
function bigNumberIshToBigint(value) {
    if (typeof value === "bigint") {
        return value;
    }
    return BigInt(value);
}
function bigNumberIshToNumber(value) {
    return Number(bigNumberIshToBigint(value));
}
//# sourceMappingURL=ethers6.js.map