"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethers5Adapter = void 0;
const universalethers = require("ethers");
const utils_js_1 = require("../chains/utils.js");
const contract_js_1 = require("../contract/contract.js");
const hex_js_1 = require("../utils/encoding/hex.js");
const resolve_promised_value_js_1 = require("../utils/promise/resolve-promised-value.js");
const wait_for_tx_receipt_js_1 = require("../transaction/actions/wait-for-tx-receipt.js");
const prepare_transaction_js_1 = require("../transaction/prepare-transaction.js");
const send_transaction_js_1 = require("../transaction/actions/send-transaction.js");
/**
 * Checks if the given ethers object is of type ethers5.
 * @param ethers - The ethers object to check.
 * @returns True if the ethers object is of type ethers5, false otherwise.
 * @internal
 */
function isEthers5(ethers) {
    return "providers" in ethers;
}
/**
 * Asserts that the provided ethers object is of type ethers5.
 * If the object is not of type ethers5, an error is thrown.
 * @param ethers - The ethers object to be asserted.
 * @throws Error - If the ethers object is not of type ethers5.
 * @internal
 */
function assertEthers5(ethers) {
    if (!isEthers5(ethers)) {
        throw new Error("You seem to be using ethers@6, please use the `ethers6Adapter()");
    }
}
exports.ethers5Adapter = (() => {
    const ethers = universalethers;
    assertEthers5(ethers);
    return {
        provider: {
            /**
             * Converts a Thirdweb client and chain ID into an ethers.js provider.
             * @param client - The Thirdweb client.
             * @param chain - The chain.
             * @returns The ethers.js provider.
             * @example
             * ```ts
             * import { ethers5Adapter } from "thirdweb/adapters/ethers5";
             * const provider = ethers5Adapter.provider.toEthers(client, chainId);
             * ```
             */
            toEthers: (client, chain) => toEthersProvider(ethers, client, chain),
        },
        contract: {
            /**
             * Converts a ThirdwebContract to an ethers.js Contract.
             * @param twContract - The ThirdwebContract to convert.
             * @returns A Promise that resolves to an ethers.js Contract.
             * @example
             * ```ts
             * import { ethers5Adapter } from "thirdweb/adapters/ethers5";
             * const ethersContract = await ethers5Adapter.contract.toEthers(twContract);
             * ```
             */
            toEthers: (twContract) => toEthersContract(ethers, twContract),
            /**
             * Creates a ThirdwebContract instance from an ethers.js contract.
             * @param options - The options for creating the ThirdwebContract instance.
             * @returns A promise that resolves to a ThirdwebContract instance.
             * @example
             * ```ts
             * import { ethers5Adapter } from "thirdweb/adapters/ethers5";
             *
             * const twContract = await ethers5Adapter.contract.fromEthersContract({
             *  client,
             *  ethersContract,
             *  chainId,
             * });
             * ```
             */
            fromEthers: (options) => fromEthersContract(options),
        },
        signer: {
            /**
             * Converts an ethers5 Signer into a Wallet object.
             * @param signer - The ethers5 Signer object.
             * @returns - A Promise that resolves to aa Wallet object.
             * @example
             * ```ts
             * import { ethers5Adapter } from "thirdweb/adapters/ethers5";
             * const wallet = await ethers5Adapter.signer.fromEthersSigner(signer);
             * ```
             */
            fromEthers: (signer) => fromEthersSigner(signer),
            /**
             * Converts a Thirdweb wallet to an ethers.js signer.
             * @param client - The thirdweb client.
             * @param account - The account.
             * @returns A promise that resolves to an ethers.js signer.
             * @example
             * ```ts
             * import { ethers5Adapter } from "thirdweb/adapters/ethers5";
             * const signer = await ethers5Adapter.signer.toEthers(client, chain, account);
             * ```
             */
            toEthers: (client, account) => toEthersSigner(ethers, client, account),
        },
    };
})();
/**
 * Converts a Thirdweb client and chain ID into an ethers.js provider.
 * @param ethers - The ethers.js library instance.
 * @param client - The Thirdweb client.
 * @param chain - The chain.
 * @returns The ethers.js provider.
 * @internal
 */
function toEthersProvider(ethers, client, chain) {
    const url = (0, utils_js_1.getRpcUrlForChain)({ chain, client });
    const headers = {
        "Content-Type": "application/json",
    };
    if (client.secretKey) {
        headers["x-secret-key"] = client.secretKey;
    }
    return new ethers.providers.JsonRpcProvider({
        url,
        headers: headers,
    });
}
/**
 * Converts a ThirdwebContract to an ethers.js Contract.
 * @param ethers - The ethers.js instance.
 * @param twContract - The ThirdwebContract to convert.
 * @returns A Promise that resolves to an ethers.js Contract.
 * @internal
 */
async function toEthersContract(ethers, twContract) {
    if (twContract.abi) {
        return new ethers.Contract(twContract.address, JSON.stringify(twContract.abi), toEthersProvider(ethers, twContract.client, twContract.chain));
    }
    const { resolveContractAbi } = await Promise.resolve().then(() => require("../contract/actions/resolve-abi.js"));
    const abi = await resolveContractAbi(twContract);
    return new ethers.Contract(twContract.address, JSON.stringify(abi), toEthersProvider(ethers, twContract.client, twContract.chain));
}
/**
 * Creates a ThirdwebContract instance from an ethers.js contract.
 * @param options - The options for creating the ThirdwebContract instance.
 * @returns A promise that resolves to a ThirdwebContract instance.
 * @internal
 */
async function fromEthersContract(options) {
    return (0, contract_js_1.getContract)({
        client: options.client,
        address: await options.ethersContract.getAddress(),
        chain: options.chain,
    });
}
/**
 * Converts an ethers5 Signer into an Account object.
 * @param signer - The ethers5 Signer object.
 * @returns - A Promise that resolves to an Account object.
 * @internal
 */
async function fromEthersSigner(signer) {
    const address = await signer.getAddress();
    const account = {
        address,
        signMessage: async ({ message }) => {
            return signer.signMessage(typeof message === "string" ? message : message.raw);
        },
        signTransaction: async (tx) => {
            return signer.signTransaction(alignTxToEthers(tx));
        },
        sendTransaction: async (tx) => {
            const result = await signer.sendTransaction(alignTxToEthers(tx));
            return {
                transactionHash: result.hash,
            };
        },
        signTypedData: async (data) => {
            return (await signer._signTypedData(data.domain, data.types, data.message));
        },
    };
    return account;
}
async function toEthersSigner(ethers, client, account) {
    class ThirdwebAdapterSigner extends ethers.Signer {
        getAddress() {
            if (!account) {
                throw new Error("Account not found");
            }
            return Promise.resolve(account.address);
        }
        signMessage(message) {
            if (!account) {
                throw new Error("Account not found");
            }
            return account.signMessage({
                message: typeof message === "string" ? message : (0, hex_js_1.uint8ArrayToHex)(message),
            });
        }
        async signTransaction(transaction) {
            if (!account) {
                throw new Error("Account not found");
            }
            if (!account.signTransaction) {
                throw new Error("Account does not support signTransaction");
            }
            const awaitedTx = await ethers.utils.resolveProperties(transaction);
            return account.signTransaction(await alignTxFromEthers(awaitedTx, ethers));
        }
        async sendTransaction(transaction) {
            if (!account) {
                throw new Error("Account not found");
            }
            if (!account.sendTransaction) {
                throw new Error("Account does not support sendTransaction");
            }
            const awaitedTx = await ethers.utils.resolveProperties(transaction);
            const alignedTx = await alignTxFromEthers(awaitedTx, ethers);
            const tx = (0, prepare_transaction_js_1.prepareTransaction)({
                client,
                chain: (0, utils_js_1.defineChain)(await (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.chainId)),
                accessList: alignedTx.accessList,
                data: alignedTx.data,
                gas: alignedTx.gas,
                maxFeePerGas: alignedTx.maxFeePerGas,
                gasPrice: alignedTx.gasPrice,
                maxFeePerBlobGas: alignedTx.maxFeePerGas,
                maxPriorityFeePerGas: alignedTx.maxPriorityFeePerGas,
                nonce: alignedTx.nonce,
                to: alignedTx.to ?? undefined,
                value: alignedTx.value,
            });
            const result = await (0, send_transaction_js_1.sendTransaction)({ transaction: tx, account });
            const response = {
                chainId: tx.chain.id,
                from: account.address,
                data: alignedTx.data ?? "0x",
                nonce: alignedTx.nonce ?? -1,
                value: ethers.BigNumber.from(alignedTx.value ?? 0),
                gasLimit: ethers.BigNumber.from(alignedTx.gas ?? 0),
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                hash: result.transactionHash,
                confirmations: 0,
                wait: async () => {
                    const receipt = await (0, wait_for_tx_receipt_js_1.waitForReceipt)(result);
                    return {
                        ...receipt,
                        type: receipt.type === "legacy"
                            ? 0
                            : receipt.type === "eip2930"
                                ? 1
                                : receipt.type === "eip1559"
                                    ? 2
                                    : 3,
                        status: receipt.status === "success" ? 1 : 0,
                        blockNumber: Number(receipt.blockNumber),
                        to: receipt.to ?? "",
                        confirmations: 1,
                        contractAddress: receipt.contractAddress ?? "",
                        transactionIndex: receipt.transactionIndex,
                        gasUsed: ethers.BigNumber.from(receipt.gasUsed),
                        logsBloom: receipt.logsBloom,
                        transactionHash: receipt.transactionHash,
                        logs: receipt.logs.map((log) => ({
                            ...log,
                            blockNumber: Number(log.blockNumber),
                        })),
                        cumulativeGasUsed: ethers.BigNumber.from(receipt.cumulativeGasUsed),
                        effectiveGasPrice: ethers.BigNumber.from(receipt.effectiveGasPrice),
                        byzantium: true,
                    };
                },
            };
            return response;
        }
        connect() {
            return this;
        }
    }
    return new ThirdwebAdapterSigner();
}
/**
 * Aligns a transaction object to fit the format expected by ethers5 library.
 * @param tx - The transaction object to align.
 * @returns The aligned transaction object.
 * @internal
 */
function alignTxToEthers(tx) {
    const { to: viemTo, type: viemType, gas, ...rest } = tx;
    // massage "to" to fit ethers
    const to = !viemTo ? Promise.resolve(undefined) : viemTo;
    // massage "type" to fit ethers
    let type;
    switch (viemType) {
        case "legacy": {
            type = 0;
            break;
        }
        case "eip2930": {
            type = 1;
            break;
        }
        case "eip1559": {
            type = 2;
            break;
        }
        case "eip4844": {
            type = 3;
            break;
        }
        default: {
            type = Promise.resolve(undefined);
            break;
        }
    }
    return { ...rest, gasLimit: gas, to, type };
}
async function alignTxFromEthers(tx, ethers) {
    const { type: ethersType, accessList, chainId, to, data, nonce, value, gasPrice, gasLimit, maxFeePerGas, maxPriorityFeePerGas, } = tx;
    switch (ethersType) {
        case 1: {
            if (!chainId) {
                throw new Error("ChainId is required for EIP-2930 transactions");
            }
            return {
                type: "eip2930",
                chainId,
                to,
                data: (data ?? undefined),
                nonce: nonce ? ethers.BigNumber.from(gasPrice).toNumber() : undefined,
                value: value ? ethers.BigNumber.from(value).toBigInt() : undefined,
                gasPrice: gasPrice
                    ? ethers.BigNumber.from(gasPrice).toBigInt()
                    : undefined,
                gas: gasLimit ? ethers.BigNumber.from(gasLimit).toBigInt() : undefined,
                accessList: accessList,
            };
        }
        case 2: {
            if (!chainId) {
                throw new Error("ChainId is required for EIP-1559 transactions");
            }
            return {
                type: "eip1559",
                chainId,
                to,
                data: (data ?? undefined),
                nonce: nonce ? ethers.BigNumber.from(gasPrice).toNumber() : undefined,
                value: value ? ethers.BigNumber.from(value).toBigInt() : undefined,
                gas: gasLimit ? ethers.BigNumber.from(gasLimit).toBigInt() : undefined,
                maxFeePerGas: maxFeePerGas
                    ? ethers.BigNumber.from(maxFeePerGas).toBigInt()
                    : undefined,
                maxPriorityFeePerGas: ethers.BigNumber.from(maxPriorityFeePerGas).toBigInt(),
                accessList: accessList,
            };
        }
        case 0:
        default: {
            return {
                type: "legacy",
                chainId,
                to,
                data: (data ?? undefined),
                nonce: nonce ? ethers.BigNumber.from(gasPrice).toNumber() : undefined,
                value: value ? ethers.BigNumber.from(value).toBigInt() : undefined,
                gasPrice: gasPrice
                    ? ethers.BigNumber.from(gasPrice).toBigInt()
                    : undefined,
                gas: gasLimit ? ethers.BigNumber.from(gasLimit).toBigInt() : undefined,
            };
        }
    }
}
//# sourceMappingURL=ethers5.js.map