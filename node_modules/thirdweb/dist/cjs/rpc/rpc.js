"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRpcClient = void 0;
const fetch_js_1 = require("../utils/fetch.js");
const json_js_1 = require("../utils/json.js");
const utils_js_1 = require("../chains/utils.js");
const RPC_CLIENT_MAP = new WeakMap();
/**
 * @internal
 */
function getRpcClientMap(client) {
    if (RPC_CLIENT_MAP.has(client)) {
        return RPC_CLIENT_MAP.get(client);
    }
    const rpcClientMap = new Map();
    RPC_CLIENT_MAP.set(client, rpcClientMap);
    return rpcClientMap;
}
/**
 * @internal
 */
function rpcRequestKey(request) {
    return `${request.method}:${JSON.stringify(request.params)}`;
}
const DEFAULT_MAX_BATCH_SIZE = 100;
// default to no timeout (next tick)
const DEFAULT_BATCH_TIMEOUT_MS = 0;
/**
 * Returns an RPC request that can be used to make JSON-RPC requests.
 * @param options - The RPC options.
 * @returns The RPC request function.
 * @rpc
 * @example
 * ```ts
 * import { createThirdwebClient } from "thirdweb";
 * import { getRpcClient } from "thirdweb/rpc";
 * import { ethereum } from "thirdweb/chains";
 * const client = createThirdwebClient({ clientId: "..." });
 * const rpcRequest = getRpcClient({ client, chain: ethereum, });
 * const blockNumber = await rpcRequest({
 *  method: "eth_blockNumber",
 * });
 * ```
 */
function getRpcClient(options) {
    const rpcClientMap = getRpcClientMap(options.client);
    const chainId = options.chain.id;
    if (rpcClientMap.has(chainId)) {
        return rpcClientMap.get(chainId);
    }
    const rpcClient = (function () {
        // we can do this upfront because it cannot change later
        const rpcUrl = (0, utils_js_1.getRpcUrlForChain)({
            client: options.client,
            chain: options.chain,
        });
        const batchSize = 
        // look at the direct options passed
        options.config?.maxBatchSize ??
            // look at the client options
            options.client.config?.rpc?.maxBatchSize ??
            // use defaults
            DEFAULT_MAX_BATCH_SIZE;
        const batchTimeoutMs = 
        // look at the direct options passed
        options.config?.batchTimeoutMs ??
            // look at the client options
            options.client.config?.rpc?.batchTimeoutMs ??
            DEFAULT_BATCH_TIMEOUT_MS;
        // inflight requests
        const inflightRequests = new Map();
        let pendingBatch = [];
        let pendingBatchTimeout = null;
        /**
         * Sends the pending batch of requests.
         * @internal
         */
        function sendPendingBatch() {
            // clear the timeout if any
            if (pendingBatchTimeout) {
                clearTimeout(pendingBatchTimeout);
                pendingBatchTimeout = null;
            }
            // prepare the requests array (we know the size)
            const requests = new Array(pendingBatch.length);
            const activeBatch = pendingBatch.slice().map((inflight, index) => {
                // assign the id to the request
                inflight.request.id = index;
                // also assign the jsonrpc version
                inflight.request.jsonrpc = "2.0";
                // assing the request to the requests array (so we don't have to map it again later)
                requests[index] = inflight.request;
                return inflight;
            });
            // reset pendingBatch to empty
            pendingBatch = [];
            fetchRpc(rpcUrl, options.client, {
                requests,
                requestTimeoutMs: options.config?.requestTimeoutMs,
            })
                .then((responses) => {
                // for each response, resolve the inflight request
                activeBatch.forEach((inflight, index) => {
                    const response = responses[index];
                    // if we didn't get a response at all, reject the inflight request
                    if (!response) {
                        inflight.reject(new Error("No response"));
                        return;
                    }
                    if ("error" in response) {
                        inflight.reject(response.error);
                        // otherwise, resolve the inflight request
                    }
                    else if (response.method === "eth_subscription") {
                        // TODO: handle subscription responses
                        throw new Error("Subscriptions not supported yet");
                    }
                    else {
                        inflight.resolve(response.result);
                    }
                    // remove the inflight request from the inflightRequests map
                    inflightRequests.delete(inflight.requestKey);
                });
            })
                .catch((err) => {
                // http call failed, reject all inflight requests
                activeBatch.forEach((inflight) => {
                    inflight.reject(err);
                    // remove the inflight request from the inflightRequests map
                    inflightRequests.delete(inflight.requestKey);
                });
            });
        }
        // shortcut everything if we do not need to batch
        if (batchSize === 1) {
            return async function (request) {
                // we can hard-code the id and jsonrpc version
                // we also mutate the request object here to avoid copying it
                request.id = 1;
                request.jsonrpc = "2.0";
                const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {
                    request: request,
                    requestTimeoutMs: options.config?.requestTimeoutMs,
                });
                if (!rpcResponse) {
                    throw new Error("No response");
                }
                if ("error" in rpcResponse) {
                    throw rpcResponse.error;
                }
                return rpcResponse.result;
            };
        }
        return async function (request) {
            const requestKey = rpcRequestKey(request);
            // if the request for this key is already inflight, return the promise directly
            if (inflightRequests.has(requestKey)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return inflightRequests.get(requestKey);
            }
            let resolve;
            let reject;
            const promise = new Promise((resolve_, reject_) => {
                resolve = resolve_;
                reject = reject_;
            });
            inflightRequests.set(requestKey, promise);
            // @ts-expect-error - they *are* definitely assgined within the promise constructor
            pendingBatch.push({ request, resolve, reject, requestKey });
            if (batchSize > 1) {
                // if there is no timeout, set one
                if (!pendingBatchTimeout) {
                    pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);
                }
                // if the batch is full, send it
                if (pendingBatch.length >= batchSize) {
                    sendPendingBatch();
                }
            }
            else {
                sendPendingBatch();
            }
            return promise;
        };
    })();
    rpcClientMap.set(chainId, rpcClient);
    return rpcClient;
}
exports.getRpcClient = getRpcClient;
/**
 * @internal
 */
async function fetchRpc(rpcUrl, client, options) {
    const response = await (0, fetch_js_1.getClientFetch)(client)(rpcUrl, {
        headers: {
            ...client.config?.rpc?.fetch?.headers,
            "Content-Type": "application/json",
        },
        body: (0, json_js_1.stringify)(options.requests),
        method: "POST",
        requestTimeoutMs: options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,
        keepalive: client.config?.rpc?.fetch?.keepalive,
    });
    if (!response.ok) {
        response.body?.cancel();
        throw new Error(`RPC request failed with status ${response.status}`);
    }
    let result;
    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        result = await response.json();
    }
    else {
        result = await response.text();
    }
    return result;
}
async function fetchSingleRpc(rpcUrl, client, options) {
    const response = await (0, fetch_js_1.getClientFetch)(client)(rpcUrl, {
        headers: {
            ...(client.config?.rpc?.fetch?.headers || {}),
            "Content-Type": "application/json",
        },
        body: (0, json_js_1.stringify)(options.request),
        method: "POST",
        requestTimeoutMs: options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,
        keepalive: client.config?.rpc?.fetch?.keepalive,
    });
    if (!response.ok) {
        response.body?.cancel();
        throw new Error(`RPC request failed with status ${response.status}`);
    }
    let result;
    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        result = await response.json();
    }
    else {
        result = await response.text();
    }
    return result;
}
//# sourceMappingURL=rpc.js.map