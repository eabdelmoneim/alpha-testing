"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultGasOverrides = exports.getGasOverridesForTransaction = void 0;
const units_js_1 = require("../utils/units.js");
const resolve_promised_value_js_1 = require("../utils/promise/resolve-promised-value.js");
const op_gas_fee_reducer_js_1 = require("./op-gas-fee-reducer.js");
const rpc_js_1 = require("../rpc/rpc.js");
const eth_getBlockByNumber_js_1 = require("../rpc/actions/eth_getBlockByNumber.js");
const eth_maxPriorityFeePerGas_js_1 = require("../rpc/actions/eth_maxPriorityFeePerGas.js");
const get_gas_price_js_1 = require("./get-gas-price.js");
/**
 *
 * @internal
 */
async function getGasOverridesForTransaction(transaction) {
    // if we have a `gasPrice` param in the transaction, use that.
    if ("gasPrice" in transaction) {
        const resolvedGasPrice = await (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.gasPrice);
        // if the value ends up being "undefined" -> continue to getting the real data
        if (resolvedGasPrice !== undefined) {
            return { gasPrice: resolvedGasPrice };
        }
    }
    // if we have a maxFeePerGas and maxPriorityFeePerGas, use those
    if ("maxFeePerGas" in transaction &&
        "maxPriorityFeePerGas" in transaction &&
        transaction.maxFeePerGas &&
        transaction.maxPriorityFeePerGas) {
        const [resolvedMaxFee, resolvedMaxPriorityFee] = await Promise.all([
            (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.maxFeePerGas),
            (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.maxPriorityFeePerGas),
        ]);
        return {
            maxFeePerGas: resolvedMaxFee,
            maxPriorityFeePerGas: resolvedMaxPriorityFee,
        };
    }
    // otherwise call getDefaultGasOverrides
    const defaultGasOverrides = await getDefaultGasOverrides(transaction.client, transaction.chain);
    if (!transaction.chain.experimental?.increaseZeroByteCount) {
        // return as is
        return defaultGasOverrides;
    }
    // otherwise adjust each value
    if (defaultGasOverrides.gasPrice) {
        return { gasPrice: (0, op_gas_fee_reducer_js_1.roundUpGas)(defaultGasOverrides.gasPrice) };
    }
    else if (defaultGasOverrides.maxFeePerGas &&
        defaultGasOverrides.maxPriorityFeePerGas) {
        return {
            maxFeePerGas: (0, op_gas_fee_reducer_js_1.roundUpGas)(defaultGasOverrides.maxFeePerGas),
            maxPriorityFeePerGas: (0, op_gas_fee_reducer_js_1.roundUpGas)(defaultGasOverrides.maxPriorityFeePerGas),
        };
    }
    // this should never happen
    return defaultGasOverrides;
}
exports.getGasOverridesForTransaction = getGasOverridesForTransaction;
/**
 * Retrieves the default gas overrides for a given client and chain ID.
 * If the fee data contains both maxFeePerGas and maxPriorityFeePerGas, it returns an object with those values.
 * Otherwise, it returns an object with the gasPrice obtained from the client and chain ID.
 * @param client - The ThirdwebClient instance.
 * @param chain - The chain ID.
 * @returns An object containing the default gas overrides.
 * @internal
 */
async function getDefaultGasOverrides(client, chain) {
    const feeData = await getDynamicFeeData(client, chain);
    if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {
        return {
            maxFeePerGas: feeData.maxFeePerGas,
            maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,
        };
    }
    else {
        return {
            gasPrice: await (0, get_gas_price_js_1.getGasPrice)({ client, chain, percentMultiplier: 10 }),
        };
    }
}
exports.getDefaultGasOverrides = getDefaultGasOverrides;
/**
 * Retrieves dynamic fee data for a given chain.
 * @param client - The Thirdweb client.
 * @param chain - The chain ID.
 * @returns A promise that resolves to the fee data.
 * @internal
 */
async function getDynamicFeeData(client, chain) {
    let maxFeePerGas = null;
    let maxPriorityFeePerGas_ = null;
    const rpcRequest = (0, rpc_js_1.getRpcClient)({ client, chain });
    const [block, maxPriorityFeePerGas] = await Promise.all([
        (0, eth_getBlockByNumber_js_1.eth_getBlockByNumber)(rpcRequest, { blockTag: "latest" }),
        (0, eth_maxPriorityFeePerGas_js_1.eth_maxPriorityFeePerGas)(rpcRequest).catch(() => null),
    ]);
    const baseBlockFee = block && block.baseFeePerGas ? block.baseFeePerGas : 100n;
    const chainId = chain.id;
    // flag chain testnet & flag chain
    if (chainId === 220 || chainId === 1220) {
        // these does not support eip-1559, for some reason even though `eth_maxPriorityFeePerGas` is available?!?
        // return null because otherwise TX break
        return { maxFeePerGas: null, maxPriorityFeePerGas: null };
        // mumbai & polygon
    }
    else if (chainId === 80001 || chainId === 137) {
        // for polygon, get fee data from gas station
        maxPriorityFeePerGas_ = await getPolygonGasPriorityFee(chainId);
    }
    else if (maxPriorityFeePerGas) {
        // prioritize fee from eth_maxPriorityFeePerGas
        maxPriorityFeePerGas_ = maxPriorityFeePerGas;
    }
    if (!maxPriorityFeePerGas_) {
        // chain does not support eip-1559, return null for both
        return { maxFeePerGas: null, maxPriorityFeePerGas: null };
    }
    // add 10% tip to maxPriorityFeePerGas for faster processing
    maxPriorityFeePerGas_ = getPreferredPriorityFee(maxPriorityFeePerGas_);
    // eip-1559 formula, doubling the base fee ensures that the tx can be included in the next 6 blocks no matter how busy the network is
    // good article on the subject: https://www.blocknative.com/blog/eip-1559-fees
    maxFeePerGas = baseBlockFee * 2n + maxPriorityFeePerGas_;
    // special cased for Celo gas fees
    if (chainId === 42220 || chainId === 44787 || chainId === 62320) {
        maxPriorityFeePerGas_ = maxFeePerGas;
    }
    return {
        maxFeePerGas,
        maxPriorityFeePerGas: maxPriorityFeePerGas_,
    };
}
/**
 * Calculates the preferred priority fee based on the default priority fee per gas and a percent multiplier.
 * @param defaultPriorityFeePerGas - The default priority fee per gas.
 * @param percentMultiplier - The percent multiplier to calculate the extra tip. Default is 10.
 * @returns The total priority fee including the extra tip.
 * @internal
 */
function getPreferredPriorityFee(defaultPriorityFeePerGas, percentMultiplier = 10) {
    const extraTip = (defaultPriorityFeePerGas / BigInt(100)) * BigInt(percentMultiplier);
    const totalPriorityFee = defaultPriorityFeePerGas + extraTip;
    return totalPriorityFee;
}
/**
 * @internal
 */
function getGasStationUrl(chainId) {
    switch (chainId) {
        case 137:
            return "https://gasstation.polygon.technology/v2";
        case 80001:
            return "https://gasstation-testnet.polygon.technology/v2";
    }
}
const MIN_POLYGON_GAS_PRICE = 31n; // 31 gwei
const MIN_MUMBAI_GAS_PRICE = 1n; // 1 gwei
/**
 * @internal
 */
function getDefaultGasFee(chainId) {
    switch (chainId) {
        case 137:
            return MIN_POLYGON_GAS_PRICE;
        case 80001:
            return MIN_MUMBAI_GAS_PRICE;
    }
}
/**
 *
 * @returns The gas price
 * @internal
 */
async function getPolygonGasPriorityFee(chainId) {
    const gasStationUrl = getGasStationUrl(chainId);
    try {
        const data = await (await fetch(gasStationUrl)).json();
        // take the standard speed here, SDK options will define the extra tip
        const priorityFee = data["fast"]["maxPriorityFee"];
        if (priorityFee > 0) {
            const fixedFee = parseFloat(priorityFee).toFixed(9);
            return (0, units_js_1.toUnits)(fixedFee, 9);
        }
    }
    catch (e) {
        console.error("failed to fetch gas", e);
    }
    return getDefaultGasFee(chainId);
}
//# sourceMappingURL=fee-data.js.map