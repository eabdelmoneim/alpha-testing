"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var I=require("@walletconnect/core"),O=require("@walletconnect/logger"),U=require("@walletconnect/types"),i=require("@walletconnect/utils"),k=require("events"),u=require("@walletconnect/time"),h=require("@walletconnect/jsonrpc-utils");function W(E){return E&&typeof E=="object"&&"default"in E?E:{default:E}}var Z=W(k);const A="wc",L=2,b="client",T=`${A}@${L}:${b}:`,V={name:b,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},ee={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_request_expire:"session_request_expire"},te={database:":memory:"},M="WALLETCONNECT_DEEPLINK_CHOICE",se={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},ie="history",re="0.3",F="proposal",ne=u.THIRTY_DAYS,Y="Proposal expired",Q="session",P=u.SEVEN_DAYS,J="engine",R={wc_sessionPropose:{req:{ttl:u.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:u.FIVE_MINUTES,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:u.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:u.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:u.ONE_DAY,prompt:!1,tag:1104},res:{ttl:u.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:u.ONE_DAY,prompt:!1,tag:1106},res:{ttl:u.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:u.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:u.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:u.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:u.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:u.ONE_DAY,prompt:!1,tag:1112},res:{ttl:u.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:u.ONE_DAY,prompt:!1,tag:1114},res:{ttl:u.ONE_DAY,prompt:!1,tag:1115}}},D={min:u.FIVE_MINUTES,max:u.SEVEN_DAYS},_={idle:"IDLE",active:"ACTIVE"},K="request",j=["wc_sessionPropose","wc_sessionRequest","wc_authRequest"];var oe=Object.defineProperty,ae=Object.defineProperties,ce=Object.getOwnPropertyDescriptors,X=Object.getOwnPropertySymbols,le=Object.prototype.hasOwnProperty,he=Object.prototype.propertyIsEnumerable,z=(E,o,t)=>o in E?oe(E,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):E[o]=t,y=(E,o)=>{for(var t in o||(o={}))le.call(o,t)&&z(E,t,o[t]);if(X)for(var t of X(o))he.call(o,t)&&z(E,t,o[t]);return E},v=(E,o)=>ae(E,ce(o));class pe extends U.IEngine{constructor(o){super(o),this.name=J,this.events=new Z.default,this.initialized=!1,this.ignoredPayloadTypes=[i.TYPE_1],this.requestQueue={state:_.idle,queue:[]},this.sessionRequestQueue={state:_.idle,queue:[]},this.requestQueueDelay=u.ONE_SECOND,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),this.client.core.pairing.register({methods:Object.keys(R)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},u.toMiliseconds(this.requestQueueDelay)))},this.connect=async t=>{await this.isInitialized();const e=v(y({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(e);const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:a,relays:c}=e;let l=s,g,d=!1;try{l&&(d=this.client.core.pairing.pairings.get(l).active)}catch(f){throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`),f}if(!l||!d){const{topic:f,uri:N}=await this.client.core.pairing.create();l=f,g=N}if(!l){const{message:f}=i.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(f)}const p=await this.client.core.crypto.generateKeyPair(),w=R.wc_sessionPropose.req.ttl||u.FIVE_MINUTES,m=i.calcExpiry(w),q=y({requiredNamespaces:r,optionalNamespaces:n,relays:c??[{protocol:I.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:p,metadata:this.client.metadata},expiryTimestamp:m},a&&{sessionProperties:a}),{reject:C,resolve:S,done:B}=i.createDelayedPromise(w,Y);this.events.once(i.engineEvent("session_connect"),async({error:f,session:N})=>{if(f)C(f);else if(N){N.self.publicKey=p;const G=v(y({},N),{requiredNamespaces:q.requiredNamespaces,optionalNamespaces:q.optionalNamespaces});await this.client.session.set(N.topic,G),await this.setExpiry(N.topic,N.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:N.peer.metadata}),S(G)}});const $=await this.sendRequest({topic:l,method:"wc_sessionPropose",params:q,throwOnFailedPublish:!0});return await this.setProposal($,y({id:$},q)),{uri:g,approval:B}},this.pair=async t=>{await this.isInitialized();try{return await this.client.core.pairing.pair(t)}catch(e){throw this.client.logger.error("pair() failed"),e}},this.approve=async t=>{await this.isInitialized();try{await this.isValidApprove(t)}catch(S){throw this.client.logger.error("approve() -> isValidApprove() failed"),S}const{id:e,relayProtocol:s,namespaces:r,sessionProperties:n}=t;let a;try{a=this.client.proposal.get(e)}catch(S){throw this.client.logger.error(`approve() -> proposal.get(${e}) failed`),S}let{pairingTopic:c,proposer:l,requiredNamespaces:g,optionalNamespaces:d}=a;c=c||"";const p=await this.client.core.crypto.generateKeyPair(),w=l.publicKey,m=await this.client.core.crypto.generateSharedKey(p,w),q=y({relay:{protocol:s??"irn"},namespaces:r,pairingTopic:c,controller:{publicKey:p,metadata:this.client.metadata},expiry:i.calcExpiry(P)},n&&{sessionProperties:n});await this.client.core.relayer.subscribe(m);const C=v(y({},q),{topic:m,requiredNamespaces:g,optionalNamespaces:d,pairingTopic:c,acknowledged:!1,self:q.controller,peer:{publicKey:l.publicKey,metadata:l.metadata},controller:p});await this.client.session.set(m,C);try{await this.sendResult({id:e,topic:c,result:{relay:{protocol:s??"irn"},responderPublicKey:p},throwOnFailedPublish:!0}),await this.sendRequest({topic:m,method:"wc_sessionSettle",params:q,throwOnFailedPublish:!0})}catch(S){throw this.client.logger.error(S),this.client.session.delete(m,i.getSdkError("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(m),S}return await this.client.core.pairing.updateMetadata({topic:c,metadata:l.metadata}),await this.client.proposal.delete(e,i.getSdkError("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:c}),await this.setExpiry(m,i.calcExpiry(P)),{topic:m,acknowledged:()=>new Promise(S=>setTimeout(()=>S(this.client.session.get(m)),500))}},this.reject=async t=>{await this.isInitialized();try{await this.isValidReject(t)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:e,reason:s}=t;let r;try{r=this.client.proposal.get(e).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`),n}r&&(await this.sendError(e,r,s),await this.client.proposal.delete(e,i.getSdkError("USER_DISCONNECTED")))},this.update=async t=>{await this.isInitialized();try{await this.isValidUpdate(t)}catch(d){throw this.client.logger.error("update() -> isValidUpdate() failed"),d}const{topic:e,namespaces:s}=t,{done:r,resolve:n,reject:a}=i.createDelayedPromise(),c=h.payloadId(),l=h.getBigIntRpcId().toString(),g=this.client.session.get(e).namespaces;return this.events.once(i.engineEvent("session_update",c),async({error:d})=>{d?a(d):(await this.client.session.update(e,{namespaces:s}),n())}),this.sendRequest({topic:e,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:l}).catch(d=>{this.client.logger.error(d),this.client.session.update(e,{namespaces:g}),a(d)}),{acknowledged:r}},this.extend=async t=>{await this.isInitialized();try{await this.isValidExtend(t)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:e}=t,s=h.payloadId(),{done:r,resolve:n,reject:a}=i.createDelayedPromise();return this.events.once(i.engineEvent("session_extend",s),({error:c})=>{c?a(c):n()}),await this.setExpiry(e,i.calcExpiry(P)),this.sendRequest({topic:e,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(c=>{a(c)}),{acknowledged:r}},this.request=async t=>{await this.isInitialized();try{await this.isValidRequest(t)}catch(p){throw this.client.logger.error("request() -> isValidRequest() failed"),p}const{chainId:e,request:s,topic:r,expiry:n=R.wc_sessionRequest.req.ttl}=t,a=h.payloadId(),c=h.getBigIntRpcId().toString(),{done:l,resolve:g,reject:d}=i.createDelayedPromise(n,"Request expired. Please try again.");return this.events.once(i.engineEvent("session_request",a),({error:p,result:w})=>{p?d(p):g(w)}),await Promise.all([new Promise(async p=>{await this.sendRequest({clientRpcId:a,relayRpcId:c,topic:r,method:"wc_sessionRequest",params:{request:v(y({},s),{expiryTimestamp:i.calcExpiry(n)}),chainId:e},expiry:n,throwOnFailedPublish:!0}).catch(w=>d(w)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:e,id:a}),p()}),new Promise(async p=>{const w=await i.getDeepLink(this.client.core.storage,M);i.handleDeeplinkRedirect({id:a,topic:r,wcDeepLink:w}),p()}),l()]).then(p=>p[2])},this.respond=async t=>{await this.isInitialized(),await this.isValidRespond(t);const{topic:e,response:s}=t,{id:r}=s;h.isJsonRpcResult(s)?await this.sendResult({id:r,topic:e,result:s.result,throwOnFailedPublish:!0}):h.isJsonRpcError(s)&&await this.sendError(r,e,s.error),this.cleanupAfterResponse(t)},this.ping=async t=>{await this.isInitialized();try{await this.isValidPing(t)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:e}=t;if(this.client.session.keys.includes(e)){const s=h.payloadId(),r=h.getBigIntRpcId().toString(),{done:n,resolve:a,reject:c}=i.createDelayedPromise();this.events.once(i.engineEvent("session_ping",s),({error:l})=>{l?c(l):a()}),await Promise.all([this.sendRequest({topic:e,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:r}),n()])}else this.client.core.pairing.pairings.keys.includes(e)&&await this.client.core.pairing.ping({topic:e})},this.emit=async t=>{await this.isInitialized(),await this.isValidEmit(t);const{topic:e,event:s,chainId:r}=t,n=h.getBigIntRpcId().toString();await this.sendRequest({topic:e,method:"wc_sessionEvent",params:{event:s,chainId:r},throwOnFailedPublish:!0,relayRpcId:n})},this.disconnect=async t=>{await this.isInitialized(),await this.isValidDisconnect(t);const{topic:e}=t;if(this.client.session.keys.includes(e))await this.sendRequest({topic:e,method:"wc_sessionDelete",params:i.getSdkError("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:e,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(e))await this.client.core.pairing.disconnect({topic:e});else{const{message:s}=i.getInternalError("MISMATCHED_TOPIC",`Session or pairing topic not found: ${e}`);throw new Error(s)}},this.find=t=>(this.isInitialized(),this.client.session.getAll().filter(e=>i.isSessionCompatible(e,t))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.cleanupDuplicatePairings=async t=>{if(t.pairingTopic)try{const e=this.client.core.pairing.pairings.get(t.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(r=>{var n,a;return((n=r.peerMetadata)==null?void 0:n.url)&&((a=r.peerMetadata)==null?void 0:a.url)===t.peer.metadata.url&&r.topic&&r.topic!==e.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}},this.deleteSession=async t=>{const{topic:e,expirerHasDeleted:s=!1,emitEvent:r=!0,id:n=0}=t,{self:a}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),await this.client.session.delete(e,i.getSdkError("USER_DISCONNECTED")),this.addToRecentlyDeleted(e,"session"),this.client.core.crypto.keychain.has(a.publicKey)&&await this.client.core.crypto.deleteKeyPair(a.publicKey),this.client.core.crypto.keychain.has(e)&&await this.client.core.crypto.deleteSymKey(e),s||this.client.core.expirer.del(e),this.client.core.storage.removeItem(M).catch(c=>this.client.logger.warn(c)),this.getPendingSessionRequests().forEach(c=>{c.topic===e&&this.deletePendingSessionRequest(c.id,i.getSdkError("USER_DISCONNECTED"))}),r&&this.client.events.emit("session_delete",{id:n,topic:e})},this.deleteProposal=async(t,e)=>{await Promise.all([this.client.proposal.delete(t,i.getSdkError("USER_DISCONNECTED")),e?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")},this.deletePendingSessionRequest=async(t,e,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,e),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==t),s&&(this.sessionRequestQueue.state=_.idle,this.client.events.emit("session_request_expire",{id:t}))},this.setExpiry=async(t,e)=>{this.client.session.keys.includes(t)&&await this.client.session.update(t,{expiry:e}),this.client.core.expirer.set(t,e)},this.setProposal=async(t,e)=>{await this.client.proposal.set(t,e),this.client.core.expirer.set(t,i.calcExpiry(R.wc_sessionPropose.req.ttl))},this.setPendingSessionRequest=async t=>{const{id:e,topic:s,params:r,verifyContext:n}=t,a=r.request.expiryTimestamp||i.calcExpiry(R.wc_sessionRequest.req.ttl);await this.client.pendingRequest.set(e,{id:e,topic:s,params:r,verifyContext:n}),a&&this.client.core.expirer.set(e,a)},this.sendRequest=async t=>{const{topic:e,method:s,params:r,expiry:n,relayRpcId:a,clientRpcId:c,throwOnFailedPublish:l}=t,g=h.formatJsonRpcRequest(s,r,c);if(i.isBrowser()&&j.includes(s)){const w=i.hashMessage(JSON.stringify(g));this.client.core.verify.register({attestationId:w})}let d;try{d=await this.client.core.crypto.encode(e,g)}catch(w){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`),w}const p=R[s].req;return n&&(p.ttl=n),a&&(p.id=a),this.client.core.history.set(e,g),l?(p.internal=v(y({},p.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(e,d,p)):this.client.core.relayer.publish(e,d,p).catch(w=>this.client.logger.error(w)),g.id},this.sendResult=async t=>{const{id:e,topic:s,result:r,throwOnFailedPublish:n}=t,a=h.formatJsonRpcResult(e,r);let c;try{c=await this.client.core.crypto.encode(s,a)}catch(d){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),d}let l;try{l=await this.client.core.history.get(s,e)}catch(d){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${e}) failed`),d}const g=R[l.request.method].res;n?(g.internal=v(y({},g.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,c,g)):this.client.core.relayer.publish(s,c,g).catch(d=>this.client.logger.error(d)),await this.client.core.history.resolve(a)},this.sendError=async(t,e,s)=>{const r=h.formatJsonRpcError(t,s);let n;try{n=await this.client.core.crypto.encode(e,r)}catch(l){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${e} failed`),l}let a;try{a=await this.client.core.history.get(e,t)}catch(l){throw this.client.logger.error(`sendError() -> history.get(${e}, ${t}) failed`),l}const c=R[a.request.method].res;this.client.core.relayer.publish(e,n,c),await this.client.core.history.resolve(r)},this.cleanup=async()=>{const t=[],e=[];this.client.session.getAll().forEach(s=>{let r=!1;i.isExpired(s.expiry)&&(r=!0),this.client.core.crypto.keychain.has(s.topic)||(r=!0),r&&t.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{i.isExpired(s.expiryTimestamp)&&e.push(s.id)}),await Promise.all([...t.map(s=>this.deleteSession({topic:s})),...e.map(s=>this.deleteProposal(s))])},this.onRelayEventRequest=async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===_.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=_.active;const t=this.requestQueue.queue.shift();if(t)try{this.processRequest(t),await new Promise(e=>setTimeout(e,300))}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=_.idle},this.processRequest=t=>{const{topic:e,payload:s}=t,r=s.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeRequest(e,s);case"wc_sessionSettle":return this.onSessionSettleRequest(e,s);case"wc_sessionUpdate":return this.onSessionUpdateRequest(e,s);case"wc_sessionExtend":return this.onSessionExtendRequest(e,s);case"wc_sessionPing":return this.onSessionPingRequest(e,s);case"wc_sessionDelete":return this.onSessionDeleteRequest(e,s);case"wc_sessionRequest":return this.onSessionRequest(e,s);case"wc_sessionEvent":return this.onSessionEventRequest(e,s);default:return this.client.logger.info(`Unsupported request method ${r}`)}},this.onRelayEventResponse=async t=>{const{topic:e,payload:s}=t,r=(await this.client.core.history.get(e,s.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(e,s);case"wc_sessionSettle":return this.onSessionSettleResponse(e,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(e,s);case"wc_sessionExtend":return this.onSessionExtendResponse(e,s);case"wc_sessionPing":return this.onSessionPingResponse(e,s);case"wc_sessionRequest":return this.onSessionRequestResponse(e,s);default:return this.client.logger.info(`Unsupported response method ${r}`)}},this.onRelayEventUnknownPayload=t=>{const{topic:e}=t,{message:s}=i.getInternalError("MISSING_OR_INVALID",`Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)},this.onSessionProposeRequest=async(t,e)=>{const{params:s,id:r}=e;try{this.isValidConnect(y({},e.params));const n=s.expiryTimestamp||i.calcExpiry(R.wc_sessionPropose.req.ttl),a=y({id:r,pairingTopic:t,expiryTimestamp:n},s);await this.setProposal(r,a);const c=i.hashMessage(JSON.stringify(e)),l=await this.getVerifyContext(c,a.proposer.metadata);this.client.events.emit("session_proposal",{id:r,params:a,verifyContext:l})}catch(n){await this.sendError(r,t,n),this.client.logger.error(n)}},this.onSessionProposeResponse=async(t,e)=>{const{id:s}=e;if(h.isJsonRpcResult(e)){const{result:r}=e;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});const n=this.client.proposal.get(s);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const a=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});const c=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:c});const l=await this.client.core.crypto.generateSharedKey(a,c);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const g=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:g}),await this.client.core.pairing.activate({topic:t})}else if(h.isJsonRpcError(e)){await this.client.proposal.delete(s,i.getSdkError("USER_DISCONNECTED"));const r=i.engineEvent("session_connect");if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners, 954`);this.events.emit(i.engineEvent("session_connect"),{error:e.error})}},this.onSessionSettleRequest=async(t,e)=>{const{id:s,params:r}=e;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:a,expiry:c,namespaces:l,sessionProperties:g,pairingTopic:d}=e.params,p=y({topic:t,relay:n,expiry:c,namespaces:l,acknowledged:!0,pairingTopic:d,requiredNamespaces:{},optionalNamespaces:{},controller:a.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}},g&&{sessionProperties:g});await this.sendResult({id:e.id,topic:t,result:!0,throwOnFailedPublish:!0});const w=i.engineEvent("session_connect");if(this.events.listenerCount(w)===0)throw new Error(`emitting ${w} without any listeners 997`);this.events.emit(i.engineEvent("session_connect"),{session:p}),this.cleanupDuplicatePairings(p)}catch(n){await this.sendError(s,t,n),this.client.logger.error(n)}},this.onSessionSettleResponse=async(t,e)=>{const{id:s}=e;h.isJsonRpcResult(e)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(i.engineEvent("session_approve",s),{})):h.isJsonRpcError(e)&&(await this.client.session.delete(t,i.getSdkError("USER_DISCONNECTED")),this.events.emit(i.engineEvent("session_approve",s),{error:e.error}))},this.onSessionUpdateRequest=async(t,e)=>{const{params:s,id:r}=e;try{const n=`${t}_session_update`,a=i.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,r)){this.client.logger.info(`Discarding out of sync request - ${r}`),this.sendError(r,t,i.getSdkError("INVALID_UPDATE_REQUEST"));return}this.isValidUpdate(y({topic:t},s));try{i.MemoryStore.set(n,r),await this.client.session.update(t,{namespaces:s.namespaces}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0})}catch(c){throw i.MemoryStore.delete(n),c}this.client.events.emit("session_update",{id:r,topic:t,params:s})}catch(n){await this.sendError(r,t,n),this.client.logger.error(n)}},this.isRequestOutOfSync=(t,e)=>parseInt(e.toString().slice(0,-3))<=parseInt(t.toString().slice(0,-3)),this.onSessionUpdateResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_update",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);h.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_update",s),{}):h.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_update",s),{error:e.error})},this.onSessionExtendRequest=async(t,e)=>{const{id:s}=e;try{this.isValidExtend({topic:t}),await this.setExpiry(t,i.calcExpiry(P)),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:t})}catch(r){await this.sendError(s,t,r),this.client.logger.error(r)}},this.onSessionExtendResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_extend",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);h.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_extend",s),{}):h.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_extend",s),{error:e.error})},this.onSessionPingRequest=async(t,e)=>{const{id:s}=e;try{this.isValidPing({topic:t}),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:t})}catch(r){await this.sendError(s,t,r),this.client.logger.error(r)}},this.onSessionPingResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_ping",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);setTimeout(()=>{h.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_ping",s),{}):h.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_ping",s),{error:e.error})},500)},this.onSessionDeleteRequest=async(t,e)=>{const{id:s}=e;try{this.isValidDisconnect({topic:t,reason:e.params}),await Promise.all([new Promise(r=>{this.client.core.relayer.once(I.RELAYER_EVENTS.publish,async()=>{r(await this.deleteSession({topic:t,id:s}))})}),this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:i.getSdkError("USER_DISCONNECTED")})])}catch(r){this.client.logger.error(r)}},this.onSessionRequest=async(t,e)=>{const{id:s,params:r}=e;try{this.isValidRequest(y({topic:t},r));const n=i.hashMessage(JSON.stringify(h.formatJsonRpcRequest("wc_sessionRequest",r,s))),a=this.client.session.get(t),c=await this.getVerifyContext(n,a.peer.metadata),l={id:s,topic:t,params:r,verifyContext:c};await this.setPendingSessionRequest(l),this.addSessionRequestToSessionRequestQueue(l),this.processSessionRequestQueue()}catch(n){await this.sendError(s,t,n),this.client.logger.error(n)}},this.onSessionRequestResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_request",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);h.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_request",s),{result:e.result}):h.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_request",s),{error:e.error})},this.onSessionEventRequest=async(t,e)=>{const{id:s,params:r}=e;try{const n=`${t}_session_event_${r.event.name}`,a=i.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(y({topic:t},r)),this.client.events.emit("session_event",{id:s,topic:t,params:r}),i.MemoryStore.set(n,s)}catch(n){await this.sendError(s,t,n),this.client.logger.error(n)}},this.addSessionRequestToSessionRequestQueue=t=>{this.sessionRequestQueue.queue.push(t)},this.cleanupAfterResponse=t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=_.idle,this.processSessionRequestQueue()},u.toMiliseconds(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:t,error:e})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(r=>r.topic===t&&r.request.method==="wc_sessionRequest").forEach(r=>{const n=r.request.id,a=i.engineEvent("session_request",n);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners`);this.events.emit(i.engineEvent("session_request",r.request.id),{error:e})})},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===_.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=_.active,this.client.events.emit("session_request",t)}catch(e){this.client.logger.error(e)}},this.onPairingCreated=t=>{if(t.active)return;const e=this.client.proposal.getAll().find(s=>s.pairingTopic===t.topic);e&&this.onSessionProposeRequest(t.topic,h.formatJsonRpcRequest("wc_sessionPropose",{requiredNamespaces:e.requiredNamespaces,optionalNamespaces:e.optionalNamespaces,relays:e.relays,proposer:e.proposer,sessionProperties:e.sessionProperties},e.id))},this.isValidConnect=async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(c)}const{pairingTopic:e,requiredNamespaces:s,optionalNamespaces:r,sessionProperties:n,relays:a}=t;if(i.isUndefined(e)||await this.isValidPairingTopic(e),!i.isValidRelays(a,!0)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`connect() relays: ${a}`);throw new Error(c)}!i.isUndefined(s)&&i.isValidObject(s)!==0&&this.validateNamespaces(s,"requiredNamespaces"),!i.isUndefined(r)&&i.isValidObject(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.validateNamespaces=(t,e)=>{const s=i.isValidRequiredNamespaces(t,"connect()",e);if(s)throw new Error(s.message)},this.isValidApprove=async t=>{if(!i.isValidParams(t))throw new Error(i.getInternalError("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:e,namespaces:s,relayProtocol:r,sessionProperties:n}=t;this.checkRecentlyDeleted(e),await this.isValidProposalId(e);const a=this.client.proposal.get(e),c=i.isValidNamespaces(s,"approve()");if(c)throw new Error(c.message);const l=i.isConformingNamespaces(a.requiredNamespaces,s,"approve()");if(l)throw new Error(l.message);if(!i.isValidString(r,!0)){const{message:g}=i.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(g)}i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.isValidReject=async t=>{if(!i.isValidParams(t)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(r)}const{id:e,reason:s}=t;if(this.checkRecentlyDeleted(e),await this.isValidProposalId(e),!i.isValidErrorReason(s)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(r)}},this.isValidSessionSettleRequest=t=>{if(!i.isValidParams(t)){const{message:l}=i.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(l)}const{relay:e,controller:s,namespaces:r,expiry:n}=t;if(!i.isValidRelay(e)){const{message:l}=i.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const a=i.isValidController(s,"onSessionSettleRequest()");if(a)throw new Error(a.message);const c=i.isValidNamespaces(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(i.isExpired(n)){const{message:l}=i.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(c)}const{topic:e,namespaces:s}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const r=this.client.session.get(e),n=i.isValidNamespaces(s,"update()");if(n)throw new Error(n.message);const a=i.isConformingNamespaces(r.requiredNamespaces,s,"update()");if(a)throw new Error(a.message)},this.isValidExtend=async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(s)}const{topic:e}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e)},this.isValidRequest=async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(c)}const{topic:e,request:s,chainId:r,expiry:n}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const{namespaces:a}=this.client.session.get(e);if(!i.isValidNamespacesChainId(a,r)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!i.isValidRequest(s)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(c)}if(!i.isValidNamespacesRequest(a,r,s.method)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(c)}if(n&&!i.isValidRequestExpiry(n,D)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${D.min} and ${D.max}`);throw new Error(c)}},this.isValidRespond=async t=>{var e;if(!i.isValidParams(t)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(n)}const{topic:s,response:r}=t;try{await this.isValidSessionTopic(s)}catch(n){throw(e=t?.response)!=null&&e.id&&this.cleanupAfterResponse(t),n}if(!i.isValidResponse(r)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(n)}},this.isValidPing=async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(s)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidEmit=async t=>{if(!i.isValidParams(t)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(a)}const{topic:e,event:s,chainId:r}=t;await this.isValidSessionTopic(e);const{namespaces:n}=this.client.session.get(e);if(!i.isValidNamespacesChainId(n,r)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(a)}if(!i.isValidEvent(s)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}if(!i.isValidNamespacesEvent(n,r,s.name)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}},this.isValidDisconnect=async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(s)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.getVerifyContext=async(t,e)=>{const s={verified:{verifyUrl:e.verifyUrl||I.VERIFY_SERVER,validation:"UNKNOWN",origin:e.url||""}};try{const r=await this.client.core.verify.resolve({attestationId:t,verifyUrl:e.verifyUrl});r&&(s.verified.origin=r.origin,s.verified.isScam=r.isScam,s.verified.validation=r.origin===new URL(e.url).origin?"VALID":"INVALID")}catch(r){this.client.logger.info(r)}return this.client.logger.info(`Verify context: ${JSON.stringify(s)}`),s},this.validateSessionProps=(t,e)=>{Object.values(t).forEach(s=>{if(!i.isValidString(s,!1)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`${e} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);throw new Error(r)}})},this.addToRecentlyDeleted=(t,e)=>{if(this.recentlyDeletedMap.set(t,e),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const r=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(s++>=r)break;this.recentlyDeletedMap.delete(n)}}},this.checkRecentlyDeleted=t=>{const e=this.recentlyDeletedMap.get(t);if(e){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`Record was recently deleted - ${e}: ${t}`);throw new Error(s)}}}async isInitialized(){if(!this.initialized){const{message:o}=i.getInternalError("NOT_INITIALIZED",this.name);throw new Error(o)}await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(I.RELAYER_EVENTS.message,async o=>{const{topic:t,message:e}=o;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(e)))return;const s=await this.client.core.crypto.decode(t,e);try{h.isJsonRpcRequest(s)?(this.client.core.history.set(t,s),this.onRelayEventRequest({topic:t,payload:s})):h.isJsonRpcResponse(s)?(await this.client.core.history.resolve(s),await this.onRelayEventResponse({topic:t,payload:s}),this.client.core.history.delete(t,s.id)):this.onRelayEventUnknownPayload({topic:t,payload:s})}catch(r){this.client.logger.error(r)}})}registerExpirerEvents(){this.client.core.expirer.on(I.EXPIRER_EVENTS.expired,async o=>{const{topic:t,id:e}=i.parseExpirerTarget(o.target);if(e&&this.client.pendingRequest.keys.includes(e))return await this.deletePendingSessionRequest(e,i.getInternalError("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):e&&(await this.deleteProposal(e,!0),this.client.events.emit("proposal_expire",{id:e}))})}registerPairingEvents(){this.client.core.pairing.events.on(I.PAIRING_EVENTS.create,o=>this.onPairingCreated(o)),this.client.core.pairing.events.on(I.PAIRING_EVENTS.delete,o=>{this.addToRecentlyDeleted(o.topic,"pairing")})}isValidPairingTopic(o){if(!i.isValidString(o,!1)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${o}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(o)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${o}`);throw new Error(t)}if(i.isExpired(this.client.core.pairing.pairings.get(o).expiry)){const{message:t}=i.getInternalError("EXPIRED",`pairing topic: ${o}`);throw new Error(t)}}async isValidSessionTopic(o){if(!i.isValidString(o,!1)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${o}`);throw new Error(t)}if(this.checkRecentlyDeleted(o),!this.client.session.keys.includes(o)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${o}`);throw new Error(t)}if(i.isExpired(this.client.session.get(o).expiry)){await this.deleteSession({topic:o});const{message:t}=i.getInternalError("EXPIRED",`session topic: ${o}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(o)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session topic does not exist in keychain: ${o}`);throw await this.deleteSession({topic:o}),new Error(t)}}async isValidSessionOrPairingTopic(o){if(this.checkRecentlyDeleted(o),this.client.session.keys.includes(o))await this.isValidSessionTopic(o);else if(this.client.core.pairing.pairings.keys.includes(o))this.isValidPairingTopic(o);else if(i.isValidString(o,!1)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${o}`);throw new Error(t)}else{const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${o}`);throw new Error(t)}}async isValidProposalId(o){if(!i.isValidId(o)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${o}`);throw new Error(t)}if(!this.client.proposal.keys.includes(o)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${o}`);throw new Error(t)}if(i.isExpired(this.client.proposal.get(o).expiryTimestamp)){await this.deleteProposal(o);const{message:t}=i.getInternalError("EXPIRED",`proposal id: ${o}`);throw new Error(t)}}}class de extends I.Store{constructor(o,t){super(o,t,F,T),this.core=o,this.logger=t}}class H extends I.Store{constructor(o,t){super(o,t,Q,T),this.core=o,this.logger=t}}class ge extends I.Store{constructor(o,t){super(o,t,K,T,e=>e.id),this.core=o,this.logger=t}}class x extends U.ISignClient{constructor(o){super(o),this.protocol=A,this.version=L,this.name=V.name,this.events=new k.EventEmitter,this.on=(e,s)=>this.events.on(e,s),this.once=(e,s)=>this.events.once(e,s),this.off=(e,s)=>this.events.off(e,s),this.removeListener=(e,s)=>this.events.removeListener(e,s),this.removeAllListeners=e=>this.events.removeAllListeners(e),this.connect=async e=>{try{return await this.engine.connect(e)}catch(s){throw this.logger.error(s.message),s}},this.pair=async e=>{try{return await this.engine.pair(e)}catch(s){throw this.logger.error(s.message),s}},this.approve=async e=>{try{return await this.engine.approve(e)}catch(s){throw this.logger.error(s.message),s}},this.reject=async e=>{try{return await this.engine.reject(e)}catch(s){throw this.logger.error(s.message),s}},this.update=async e=>{try{return await this.engine.update(e)}catch(s){throw this.logger.error(s.message),s}},this.extend=async e=>{try{return await this.engine.extend(e)}catch(s){throw this.logger.error(s.message),s}},this.request=async e=>{try{return await this.engine.request(e)}catch(s){throw this.logger.error(s.message),s}},this.respond=async e=>{try{return await this.engine.respond(e)}catch(s){throw this.logger.error(s.message),s}},this.ping=async e=>{try{return await this.engine.ping(e)}catch(s){throw this.logger.error(s.message),s}},this.emit=async e=>{try{return await this.engine.emit(e)}catch(s){throw this.logger.error(s.message),s}},this.disconnect=async e=>{try{return await this.engine.disconnect(e)}catch(s){throw this.logger.error(s.message),s}},this.find=e=>{try{return this.engine.find(e)}catch(s){throw this.logger.error(s.message),s}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}},this.name=o?.name||V.name,this.metadata=o?.metadata||i.getAppMetadata();const t=typeof o?.logger<"u"&&typeof o?.logger!="string"?o.logger:O.pino(O.getDefaultLoggerOptions({level:o?.logger||V.logger}));this.core=o?.core||new I.Core(o),this.logger=O.generateChildLogger(t,this.name),this.session=new H(this.core,this.logger),this.proposal=new de(this.core,this.logger),this.pendingRequest=new ge(this.core,this.logger),this.engine=new pe(this)}static async init(o){const t=new x(o);return await t.initialize(),t}get context(){return O.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success")}catch(o){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(o.message),o}}}const ue=H,Ee=x;exports.ENGINE_CONTEXT=J,exports.ENGINE_QUEUE_STATES=_,exports.ENGINE_RPC_OPTS=R,exports.HISTORY_CONTEXT=ie,exports.HISTORY_EVENTS=se,exports.HISTORY_STORAGE_VERSION=re,exports.METHODS_TO_VERIFY=j,exports.PROPOSAL_CONTEXT=F,exports.PROPOSAL_EXPIRY=ne,exports.PROPOSAL_EXPIRY_MESSAGE=Y,exports.REQUEST_CONTEXT=K,exports.SESSION_CONTEXT=Q,exports.SESSION_EXPIRY=P,exports.SESSION_REQUEST_EXPIRY_BOUNDARIES=D,exports.SIGN_CLIENT_CONTEXT=b,exports.SIGN_CLIENT_DEFAULT=V,exports.SIGN_CLIENT_EVENTS=ee,exports.SIGN_CLIENT_PROTOCOL=A,exports.SIGN_CLIENT_STORAGE_OPTIONS=te,exports.SIGN_CLIENT_STORAGE_PREFIX=T,exports.SIGN_CLIENT_VERSION=L,exports.SessionStore=ue,exports.SignClient=Ee,exports.WALLETCONNECT_DEEPLINK_CHOICE=M,exports.default=x;
//# sourceMappingURL=index.cjs.js.map
